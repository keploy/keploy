package yaml

import (
	"context"
	"io"
	"os"
	"path/filepath"
	"testing"

	"go.uber.org/zap"
)

// getTestLogger creates a test logger
func getTestLogger() *zap.Logger {
	logger, _ := zap.NewDevelopment()
	return logger
}

// TestMockReaderWindowsLineEndings tests that the reader correctly handles
// Windows-style CRLF (\r\n) line endings
func TestMockReaderWindowsLineEndings(t *testing.T) {
	ctx := context.Background()
	logger := getTestLogger()

	// Create a temporary directory
	tempDir, err := os.MkdirTemp("", "mockreader_windows_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create mock content with Windows-style CRLF line endings
	// Using explicit \r\n to simulate Windows line endings
	windowsMockContent := "# Generated by Keploy\r\n" +
		"---\r\n" +
		"version: api.keploy.io/v1beta1\r\n" +
		"kind: Http\r\n" +
		"name: mock-1\r\n" +
		"spec:\r\n" +
		"    metadata:\r\n" +
		"        type: config\r\n" +
		"    requests:\r\n" +
		"        - header:\r\n" +
		"            length: 100\r\n" +
		"    created: 1767366025\r\n" +
		"---\r\n" +
		"version: api.keploy.io/v1beta1\r\n" +
		"kind: Http\r\n" +
		"name: mock-2\r\n" +
		"spec:\r\n" +
		"    metadata:\r\n" +
		"        type: config\r\n" +
		"    requests:\r\n" +
		"        - header:\r\n" +
		"            length: 200\r\n" +
		"    created: 1767366026\r\n" +
		"---\r\n" +
		"version: api.keploy.io/v1beta1\r\n" +
		"kind: Http\r\n" +
		"name: mock-3\r\n" +
		"spec:\r\n" +
		"    metadata:\r\n" +
		"        type: config\r\n" +
		"    requests:\r\n" +
		"        - header:\r\n" +
		"            length: 300\r\n" +
		"    created: 1767366027\r\n"

	// Write the mock file with Windows line endings
	mockFilePath := filepath.Join(tempDir, "mocks.yaml")
	err = os.WriteFile(mockFilePath, []byte(windowsMockContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write mock file: %v", err)
	}

	// Verify the file was written with CRLF
	fileContent, err := os.ReadFile(mockFilePath)
	if err != nil {
		t.Fatalf("Failed to read mock file: %v", err)
	}
	crlfCount := 0
	for i := 0; i < len(fileContent)-1; i++ {
		if fileContent[i] == '\r' && fileContent[i+1] == '\n' {
			crlfCount++
		}
	}
	t.Logf("File contains %d CRLF sequences", crlfCount)

	// Create the reader and read mocks
	reader, err := NewMockReader(ctx, logger, tempDir, "mocks")
	if err != nil {
		t.Fatalf("Failed to create MockReader: %v", err)
	}
	defer reader.Close()

	expectedNames := []string{"mock-1", "mock-2", "mock-3"}
	mockCount := 0

	for {
		doc, err := reader.ReadNextDoc()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Fatalf("Failed to read mock %d: %v", mockCount, err)
		}

		// Validate document
		if mockCount < len(expectedNames) {
			if doc.Name != expectedNames[mockCount] {
				t.Errorf("Mock %d name mismatch: got %q, want %q", mockCount, doc.Name, expectedNames[mockCount])
			}
		}

		t.Logf("Successfully read mock: %s (kind: %s)", doc.Name, doc.Kind)
		mockCount++
	}

	if mockCount != 3 {
		t.Errorf("Mock count mismatch: got %d, want 3", mockCount)
	}

	t.Logf("Successfully read %d mocks with Windows CRLF line endings", mockCount)
}

// TestMockReaderMixedLineEndings tests handling of files with mixed line endings
// (which can happen when files are edited on different platforms)
func TestMockReaderMixedLineEndings(t *testing.T) {
	ctx := context.Background()
	logger := getTestLogger()

	// Create a temporary directory
	tempDir, err := os.MkdirTemp("", "mockreader_mixed_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create mock content with mixed line endings (some LF, some CRLF)
	mixedMockContent := "# Generated by Keploy\n" + // Unix LF
		"---\r\n" + // Windows CRLF
		"version: api.keploy.io/v1beta1\n" + // Unix LF
		"kind: Http\r\n" + // Windows CRLF
		"name: mock-mixed-1\n" + // Unix LF
		"spec:\r\n" + // Windows CRLF
		"    metadata:\n" + // Unix LF
		"        type: config\n" +
		"    created: 1767366025\n" +
		"---\n" + // Unix LF separator
		"version: api.keploy.io/v1beta1\r\n" + // Windows CRLF
		"kind: Http\n" + // Unix LF
		"name: mock-mixed-2\r\n" + // Windows CRLF
		"spec:\n" +
		"    metadata:\r\n" +
		"        type: config\n" +
		"    created: 1767366026\n"

	// Write the mock file
	mockFilePath := filepath.Join(tempDir, "mocks.yaml")
	err = os.WriteFile(mockFilePath, []byte(mixedMockContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write mock file: %v", err)
	}

	// Create the reader and read mocks
	reader, err := NewMockReader(ctx, logger, tempDir, "mocks")
	if err != nil {
		t.Fatalf("Failed to create MockReader: %v", err)
	}
	defer reader.Close()

	expectedNames := []string{"mock-mixed-1", "mock-mixed-2"}
	mockCount := 0

	for {
		doc, err := reader.ReadNextDoc()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Fatalf("Failed to read mock %d: %v", mockCount, err)
		}

		// Validate document
		if mockCount < len(expectedNames) {
			if doc.Name != expectedNames[mockCount] {
				t.Errorf("Mock %d name mismatch: got %q, want %q", mockCount, doc.Name, expectedNames[mockCount])
			}
		}

		t.Logf("Successfully read mock: %s (kind: %s)", doc.Name, doc.Kind)
		mockCount++
	}

	if mockCount != 2 {
		t.Errorf("Mock count mismatch: got %d, want 2", mockCount)
	}

	t.Logf("Successfully read %d mocks with mixed line endings", mockCount)
}
