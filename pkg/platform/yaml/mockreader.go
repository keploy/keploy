package yaml

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"go.keploy.io/server/v3/utils"
	"go.uber.org/zap"
	yamlLib "gopkg.in/yaml.v3"
)

// MockFileReader provides buffered, delimiter-based reading of mock YAML files.
// Instead of loading the entire file into memory, it reads one YAML document at a time
// using the "---" delimiter, making it memory-efficient for large mock files.
type MockFileReader struct {
	file    *os.File
	scanner *bufio.Scanner
	ctx     context.Context
	logger  *zap.Logger
	path    string
	buffer  bytes.Buffer
	done    bool
}

// NewMockFileReader creates a new MockFileReader for reading mock files incrementally.
// The reader uses buffered I/O with the "---" YAML document separator as delimiter.
func NewMockFileReader(ctx context.Context, logger *zap.Logger, path, name string) (*MockFileReader, error) {
	filePath := filepath.Join(path, name+".yaml")
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open mock file: %w", err)
	}

	reader := &MockFileReader{
		file:   file,
		ctx:    ctx,
		logger: logger,
		path:   filePath,
		done:   false,
	}

	// Create a scanner with custom split function for YAML documents
	reader.scanner = bufio.NewScanner(file)
	reader.scanner.Split(reader.splitYAMLDocuments)

	// Set a larger buffer for the scanner to handle large YAML documents
	// Default is 64KB, setting to 10MB to handle large mocks
	const maxScanTokenSize = 10 * 1024 * 1024
	buf := make([]byte, 0, 64*1024)
	reader.scanner.Buffer(buf, maxScanTokenSize)

	return reader, nil
}

// splitYAMLDocuments is a custom split function for bufio.Scanner that splits
// on YAML document separators ("---" at the start of a line).
func (r *MockFileReader) splitYAMLDocuments(data []byte, atEOF bool) (advance int, token []byte, err error) {
	// Check for context cancellation
	select {
	case <-r.ctx.Done():
		return 0, nil, r.ctx.Err()
	default:
	}

	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}

	// Skip leading whitespace and the initial "---" if present
	start := 0

	// Skip comment lines at the beginning (like "# Generated by Keploy")
	for start < len(data) {
		// Skip whitespace
		for start < len(data) && (data[start] == ' ' || data[start] == '\t' || data[start] == '\n' || data[start] == '\r') {
			start++
		}
		// Skip comment lines
		if start < len(data) && data[start] == '#' {
			// Find end of line
			end := bytes.IndexByte(data[start:], '\n')
			if end == -1 {
				if atEOF {
					return len(data), nil, nil
				}
				return 0, nil, nil // Need more data
			}
			start += end + 1
			continue
		}
		break
	}

	// Check if we start with "---"
	if start+3 <= len(data) && string(data[start:start+3]) == "---" {
		start += 3
		// Skip newline after --- (handle both \r\n and \n)
		if start < len(data) && data[start] == '\r' {
			start++
		}
		if start < len(data) && data[start] == '\n' {
			start++
		}
	}

	// Now find the next "---" delimiter (must be at start of line)
	searchStart := start
	for {
		// Look for "\n---" or "\r\n---" pattern (support both Unix and Windows line endings)
		idx := bytes.Index(data[searchStart:], []byte("\n---"))
		idxCRLF := bytes.Index(data[searchStart:], []byte("\r\n---"))

		// Use the earlier match if both exist, prefer \r\n--- if at same effective position
		if idx == -1 && idxCRLF == -1 {
			// No delimiter found
			if atEOF {
				// Return remaining content
				token = bytes.TrimSpace(data[start:])
				if len(token) == 0 {
					return len(data), nil, nil
				}
				return len(data), token, nil
			}
			// Need more data
			return 0, nil, nil
		}

		// Determine which delimiter to use
		isCRLF := false
		if idx == -1 {
			idx = idxCRLF
			isCRLF = true
		} else if idxCRLF != -1 && idxCRLF < idx {
			idx = idxCRLF
			isCRLF = true
		}

		// Found a delimiter at searchStart + idx
		delimPos := searchStart + idx

		// Calculate delimiter length and position after delimiter
		delimLen := 4 // Length of "\n---"
		if isCRLF {
			delimLen = 5 // Length of "\r\n---"
		}
		afterDelim := delimPos + delimLen // Position after the delimiter pattern

		// Make sure this "---" is followed by newline or is at end of file
		if afterDelim < len(data) && data[afterDelim] != '\n' && data[afterDelim] != '\r' && data[afterDelim] != ' ' {
			// This is not a valid delimiter (e.g., "---something")
			searchStart = afterDelim
			continue
		}

		// Extract the token (content between start and the delimiter)
		token = bytes.TrimSpace(data[start:delimPos])

		// Advance past the content and the line ending (but "---" will be part of next iteration)
		if isCRLF {
			advance = delimPos + 2 // Skip \r\n
		} else {
			advance = delimPos + 1 // Skip \n
		}

		if len(token) == 0 {
			// Empty document, skip and continue
			start = advance + 3 // Skip the "---"
			// Skip newline after --- (handle both \r\n and \n)
			if start < len(data) && data[start] == '\r' {
				start++
			}
			if start < len(data) && data[start] == '\n' {
				start++
			}
			searchStart = start
			continue
		}

		return advance, token, nil
	}
}

// ReadNext reads the next YAML document from the mock file.
// It returns the raw bytes of the next document, or io.EOF when all documents have been read.
func (r *MockFileReader) ReadNext() ([]byte, error) {
	// Check for context cancellation
	select {
	case <-r.ctx.Done():
		return nil, r.ctx.Err()
	default:
	}

	if r.done {
		return nil, io.EOF
	}

	if r.scanner.Scan() {
		return r.scanner.Bytes(), nil
	}

	// Check for errors
	if err := r.scanner.Err(); err != nil {
		return nil, fmt.Errorf("failed to read mock document: %w", err)
	}

	r.done = true
	return nil, io.EOF
}

// ReadNextDoc reads and decodes the next YAML document into a NetworkTrafficDoc.
// It returns io.EOF when all documents have been read.
func (r *MockFileReader) ReadNextDoc() (*NetworkTrafficDoc, error) {
	data, err := r.ReadNext()
	if err != nil {
		return nil, err
	}

	// Handle empty documents (skip them)
	if len(bytes.TrimSpace(data)) == 0 {
		return r.ReadNextDoc() // Recursively get next non-empty doc
	}

	var doc NetworkTrafficDoc
	if err := yamlLib.Unmarshal(data, &doc); err != nil {
		return nil, fmt.Errorf("failed to decode YAML document: %w", err)
	}

	return &doc, nil
}

// Close closes the underlying file.
func (r *MockFileReader) Close() error {
	if r.file != nil {
		if err := r.file.Close(); err != nil {
			utils.LogError(r.logger, err, "failed to close mock file", zap.String("file", r.path))
			return err
		}
	}
	return nil
}

// LineBasedMockReader provides line-by-line reading with "---" as the document delimiter.
// This is an alternative implementation that reads line by line and accumulates until delimiter.
type LineBasedMockReader struct {
	file    *os.File
	reader  *bufio.Reader
	ctx     context.Context
	logger  *zap.Logger
	path    string
	lineNum int
	done    bool
}

// NewLineBasedMockReader creates a reader that accumulates lines until "---" delimiter.
func NewLineBasedMockReader(ctx context.Context, logger *zap.Logger, path, name string) (*LineBasedMockReader, error) {
	filePath := filepath.Join(path, name+".yaml")
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open mock file: %w", err)
	}

	return &LineBasedMockReader{
		file:    file,
		reader:  bufio.NewReader(file),
		ctx:     ctx,
		logger:  logger,
		path:    filePath,
		lineNum: 0,
		done:    false,
	}, nil
}

// ReadNextDocument reads lines until it encounters "---" or EOF, returning the accumulated document.
func (r *LineBasedMockReader) ReadNextDocument() ([]byte, error) {
	if r.done {
		return nil, io.EOF
	}

	var buffer bytes.Buffer
	isFirstDoc := r.lineNum == 0

	for {
		// Check for context cancellation
		select {
		case <-r.ctx.Done():
			return nil, r.ctx.Err()
		default:
		}

		line, err := r.reader.ReadString('\n')
		r.lineNum++

		if err != nil {
			if err == io.EOF {
				r.done = true
				// Return what we have if there's content
				if buffer.Len() > 0 {
					return buffer.Bytes(), nil
				}
				return nil, io.EOF
			}
			return nil, fmt.Errorf("failed to read line %d: %w", r.lineNum, err)
		}

		trimmedLine := strings.TrimSpace(line)

		// Check if this line is a document separator
		if trimmedLine == "---" {
			// If buffer is empty and this is a separator, skip it (start of file)
			if buffer.Len() == 0 {
				continue
			}
			// Return the accumulated document
			return buffer.Bytes(), nil
		}

		// Skip comment lines at the very beginning (like "# Generated by Keploy")
		if isFirstDoc && buffer.Len() == 0 && strings.HasPrefix(trimmedLine, "#") {
			continue
		}

		// Accumulate the line
		buffer.WriteString(line)
	}
}

// ReadNextDoc reads and decodes the next document.
func (r *LineBasedMockReader) ReadNextDoc() (*NetworkTrafficDoc, error) {
	data, err := r.ReadNextDocument()
	if err != nil {
		return nil, err
	}

	if len(bytes.TrimSpace(data)) == 0 {
		return r.ReadNextDoc()
	}

	var doc NetworkTrafficDoc
	if err := yamlLib.Unmarshal(data, &doc); err != nil {
		return nil, fmt.Errorf("failed to decode YAML at line %d: %w", r.lineNum, err)
	}

	return &doc, nil
}

// Close closes the file.
func (r *LineBasedMockReader) Close() error {
	if r.file != nil {
		return r.file.Close()
	}
	return nil
}
