package golang

import (
	"debug/elf"
	"fmt"
	"os"
	"slices"
	"strconv"
	"strings"

	"go.keploy.io/server/v2/utils"
	"go.uber.org/zap"
)

// checkForCoverFlag checks if the given Go binary has the coverage flag enabled if one argument
// else check if -cover flag is passed or not
// TODO: use native approach till https://github.com/golang/go/issues/67366 gets resolved
func checkForCoverFlag(logger *zap.Logger, cmd string) bool {
	cmdFields := strings.Fields(cmd)
	if cmdFields[0] == "go" && len(cmdFields) > 1 {
		if slices.Contains(cmdFields, "-cover") {
			return true
		}
		logger.Warn("cover flag not found in command, skipping coverage calculation")
		return false
	}
	file, err := elf.Open(cmdFields[0])
	if err != nil {
		utils.LogError(logger, err, "failed to open file, skipping coverage calculation")
		return false
	}
	defer func() {
		if err := file.Close(); err != nil {
			utils.LogError(logger, err, "failed to close binary file", zap.String("file", cmd))
		}
	}()

	symbols, err := file.Symbols()
	if err != nil {
		utils.LogError(logger, err, "failed to read symbols, skipping coverage calculation")
		return false
	}

	for _, symbol := range symbols {
		// Check for symbols that related to Go coverage instrumentation
		if strings.Contains(symbol.Name, "internal/coverage") {
			return true
		}
	}
	logger.Warn("go binary was not build with -cover flag", zap.String("file", cmd))
	return false
}

func ParseTextFmtFile() (map[string][]int, error) {
	coveragePerFile := make(map[string][]int) // filename -> [noOfLines, coveredLines]
	covdata, err := os.ReadFile(os.Getenv("GOCOVERDIR") + "/total-coverage.txt")
	if err != nil {
		return nil, err
	}
	malformedErrMsg := "coverage file generated by \"go tool covdata textfmt\" is malformed"
	// a line is of the form: <filename>:<startLineRow>.<startLineCol>,<endLineRow>.<endLineCol> <noOfLines> <coveredOrNot>
	for idx, line := range strings.Split(string(covdata), "\n") {
		line = strings.TrimSpace(line)
		if strings.Split(line, ":")[0] == "mode" || line == "" {
			continue
		}

		lineFields := strings.Fields(line)
		if len(lineFields) != 3 {
			return nil, fmt.Errorf("%s at line no %d", malformedErrMsg, idx)
		}

		noOfLines, err := strconv.Atoi(lineFields[1])
		if err != nil {
			return nil, err
		}
		coveredOrNot, err := strconv.Atoi(lineFields[2])
		if err != nil {
			return nil, err
		}

		i := strings.Index(line, ":")
		var filepath string
		if i > 0 {
			filepath = line[:i]
		} else {
			return nil, fmt.Errorf("%s at line %d, missing color in filepath", malformedErrMsg, idx)
		}

		if _, ok := coveragePerFile[filepath]; !ok {
			coveragePerFile[filepath] = make([]int, 2)
		}

		coveragePerFile[filepath][0] += noOfLines
		if coveredOrNot != 0 {
			coveragePerFile[filepath][1] += noOfLines
		}
	}
	return coveragePerFile, nil
}

func ParseFuncFmtFile(funcCoverageOutput string) (map[string][]int, error) {
	coveragePerFile := make(map[string][]int) // filename -> [noOfFunctions, noOfCoveredFunctions]

	malformedErrMsg := "coverage file generated by \"go tool covdata func\" is malformed"
	lines := strings.Split(funcCoverageOutput, "\n")

	// a line is of the form: <filepath>:<functionStartLineNo>: <functionName> <percentage>
	for idx, line := range lines {
		line = strings.TrimSpace(line)
		lineFields := strings.Fields(line)
		if line == "" {
			continue
		} else if len(lineFields) != 3 {
			return nil, fmt.Errorf("%s at line %d", malformedErrMsg, idx)
		} else if lineFields[1] == "(statements)" {
			// last line is of the form "total (statements) <percentage>"
			break
		}

		i := strings.Index(line, ":")
		var filepath string
		if i > 0 {
			filepath = line[:i]
		} else {
			return nil, fmt.Errorf("%s at line %d, missing colon in filepath", malformedErrMsg, idx)
		}

		percent, err := strconv.ParseFloat(strings.TrimSuffix(lineFields[2], "%"), 64)
		if err != nil {
			return nil, err
		}

		if _, ok := coveragePerFile[filepath]; !ok {
			coveragePerFile[filepath] = make([]int, 2)
		}

		coveragePerFile[filepath][0]++
		if percent > 0 {
			coveragePerFile[filepath][1]++
		}
	}
	return coveragePerFile, nil
}
