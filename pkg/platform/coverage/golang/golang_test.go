package golang

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"go.keploy.io/server/v3/utils/log"
)

func TestIsMockeryFile(t *testing.T) {
	logger, _, err := log.New()
	if err != nil {
		t.Fatalf("Failed to create logger: %v", err)
	}
	g := &Golang{
		ctx:    context.Background(),
		logger: logger,
	}

	tests := []struct {
		name     string
		content  string
		filename string
		want     bool
	}{
		{
			name:     "Mockery v2 generated file",
			filename: "mock_Repository.go",
			content:  "// Code generated by mockery v2.53.2. DO NOT EDIT.\npackage service\n\nimport mock \"github.com/stretchr/testify/mock\"",
			want:     true,
		},
		{
			name:     "Mockery v3 generated file",
			filename: "mock_Service.go",
			content:  "// Code generated by mockery. DO NOT EDIT.\npackage mocks\n\nimport mock \"github.com/stretchr/testify/mock\"",
			want:     true,
		},
		{
			name:     "Mockery v1 generated file",
			filename: "mock_Database.go",
			content:  "// Code generated by mockery v1.0.0. DO NOT EDIT.\npackage service",
			want:     true,
		},
		{
			name:     "Custom mock file (no header)",
			filename: "mock_custom.go",
			content:  "package service\n\ntype MockService struct {}",
			want:     false,
		},
		{
			name:     "Regular Go file",
			filename: "user.go",
			content:  "package service\n\nfunc GetUser() {}",
			want:     false,
		},
		{
			name:     "Non-mock file with mock prefix",
			filename: "mock_data.go",
			content:  "package testdata\n\nvar MockData = []string{}",
			want:     false,
		},
		{
			name:     "File without mock prefix",
			filename: "service_test.go",
			content:  "package service\n\nimport \"testing\"",
			want:     false,
		},
		{
			name:     "Mock file with different comment",
			filename: "mock_helper.go",
			content:  "// This is a custom mock helper\npackage service",
			want:     false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temp file
			tmpDir := t.TempDir()
			tmpFile := filepath.Join(tmpDir, tt.filename)

			if err := os.WriteFile(tmpFile, []byte(tt.content), 0644); err != nil {
				t.Fatalf("Failed to create test file: %v", err)
			}

			got := g.isMockeryFile(tmpFile)
			if got != tt.want {
				t.Errorf("isMockeryFile() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsMockeryFile_ErrorHandling(t *testing.T) {
	logger, _, err := log.New()
	if err != nil {
		t.Fatalf("Failed to create logger: %v", err)
	}
	g := &Golang{
		ctx:    context.Background(),
		logger: logger,
	}

	t.Run("Non-existent file", func(t *testing.T) {
		// Test non-existent file (should return false, not panic)
		result := g.isMockeryFile("/nonexistent/mock_file.go")
		if result != false {
			t.Errorf("Expected false for non-existent file, got %v", result)
		}
	})

	t.Run("Empty filename", func(t *testing.T) {
		result := g.isMockeryFile("")
		if result != false {
			t.Errorf("Expected false for empty filename, got %v", result)
		}
	})

	t.Run("Directory instead of file", func(t *testing.T) {
		tmpDir := t.TempDir()
		mockDir := filepath.Join(tmpDir, "mock_directory.go")
		if err := os.Mkdir(mockDir, 0755); err != nil {
			t.Fatalf("Failed to create directory: %v", err)
		}

		result := g.isMockeryFile(mockDir)
		if result != false {
			t.Errorf("Expected false for directory, got %v", result)
		}
	})
}

func TestIsMockeryFile_RealKeployFiles(t *testing.T) {
	logger, _, err := log.New()
	if err != nil {
		t.Fatalf("Failed to create logger: %v", err)
	}
	g := &Golang{
		ctx:    context.Background(),
		logger: logger,
	}

	// Test with actual Keploy mockery files (if they exist)
	testFiles := []struct {
		path         string
		shouldFilter bool
		description  string
	}{
		{
			path:         "pkg/models/mock_Secret.go",
			shouldFilter: true,
			description:  "Keploy's mockery-generated Secret mock",
		},
		{
			path:         "pkg/service/orchestrator/mock_correlation.go",
			shouldFilter: false,
			description:  "Keploy's custom mock (not mockery-generated)",
		},
	}

	for _, tt := range testFiles {
		t.Run(tt.description, func(t *testing.T) {
			// Check if file exists in the codebase
			if _, err := os.Stat(tt.path); os.IsNotExist(err) {
				t.Skipf("File %s does not exist in codebase", tt.path)
				return
			}

			result := g.isMockeryFile(tt.path)
			if result != tt.shouldFilter {
				t.Errorf("isMockeryFile(%s) = %v, want %v", tt.path, result, tt.shouldFilter)
			}
		})
	}
}

func TestIsMockeryFile_PerformancePattern(t *testing.T) {
	logger, _, err := log.New()
	if err != nil {
		t.Fatalf("Failed to create logger: %v", err)
	}
	g := &Golang{
		ctx:    context.Background(),
		logger: logger,
	}

	// Test that non-mock files are quickly filtered without file I/O
	testCases := []string{
		"user.go",
		"service.go",
		"handler_test.go",
		"README.md",
		"config.yaml",
	}

	for _, filename := range testCases {
		t.Run(filename, func(t *testing.T) {
			// These shouldn't trigger file I/O (fast path)
			// We can verify by not creating the file at all
			result := g.isMockeryFile("/nonexistent/path/" + filename)
			if result != false {
				t.Errorf("Non-mock file %s incorrectly identified as mockery file", filename)
			}
		})
	}
}
