package mcp

import (
	"fmt"
	"strings"
)

// generateGitHubActionsWorkflow generates a GitHub Actions workflow for Keploy mock testing.
func generateGitHubActionsWorkflow(config PipelineConfig) string {
	return fmt.Sprintf(`# Keploy Mock Test Workflow
# This workflow runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool

name: Keploy Mock Test

on:
  pull_request:
    branches: [%s]
  push:
    branches: [%s]

jobs:
  keploy-mock-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Keploy
        run: |
          curl --silent --location "https://github.com/keploy/keploy/releases/latest/download/keploy_linux_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/keploy /usr/local/bin/keploy
          keploy --version

      - name: Run Keploy Mock Test
        run: |
          keploy mock test --command "%s" --mockPath "%s"
        env:
          # Add any environment variables your app needs
          CI: true
`,
		config.DefaultBranch,
		config.DefaultBranch,
		config.DefaultBranch,
		config.AppCommand,
		config.MockPath,
	)
}

// generateGitLabCIPipeline generates a GitLab CI/CD pipeline for Keploy mock testing.
func generateGitLabCIPipeline(config PipelineConfig) string {
	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on merge requests and merges to %s
# Generated by Keploy MCP Tool

stages:
  - test

variables:
  KEPLOY_MOCK_PATH: "%s"
  APP_COMMAND: "%s"

keploy-mock-test:
  stage: test
  image: ubuntu:22.04
  
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "%s"
  
  before_script:
    - apt-get update && apt-get install -y curl tar
    - curl --silent --location "https://github.com/keploy/keploy/releases/latest/download/keploy_linux_amd64.tar.gz" | tar xz -C /tmp
    - mv /tmp/keploy /usr/local/bin/keploy
    - keploy --version
  
  script:
    - keploy mock test --command "${APP_COMMAND}" --mockPath "${KEPLOY_MOCK_PATH}"
`,
		config.DefaultBranch,
		config.MockPath,
		config.AppCommand,
		config.DefaultBranch,
	)
}

// generateJenkinsfile generates a Jenkinsfile for Keploy mock testing.
func generateJenkinsfile(config PipelineConfig) string {
	return fmt.Sprintf(`// Keploy Mock Test Pipeline
// This pipeline runs Keploy mock tests on pull requests and merges to %s
// Generated by Keploy MCP Tool

pipeline {
    agent any

    environment {
        KEPLOY_MOCK_PATH = '%s'
        APP_COMMAND = '%s'
    }

    triggers {
        // Trigger on PRs and merges to %s
        pollSCM('H/5 * * * *')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Setup Keploy') {
            steps {
                sh '''
                    curl --silent --location "https://github.com/keploy/keploy/releases/latest/download/keploy_linux_amd64.tar.gz" | tar xz -C /tmp
                    sudo mv /tmp/keploy /usr/local/bin/keploy
                    keploy --version
                '''
            }
        }

        stage('Keploy Mock Test') {
            steps {
                sh '''
                    keploy mock test --command "${APP_COMMAND}" --mockPath "${KEPLOY_MOCK_PATH}"
                '''
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}
`,
		config.DefaultBranch,
		config.MockPath,
		config.AppCommand,
		config.DefaultBranch,
	)
}

// generateCircleCIConfig generates a CircleCI configuration for Keploy mock testing.
func generateCircleCIConfig(config PipelineConfig) string {
	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool

version: 2.1

executors:
  default:
    docker:
      - image: cimg/base:current
    working_directory: ~/project

jobs:
  keploy-mock-test:
    executor: default
    steps:
      - checkout
      
      - run:
          name: Setup Keploy
          command: |
            curl --silent --location "https://github.com/keploy/keploy/releases/latest/download/keploy_linux_amd64.tar.gz" | tar xz -C /tmp
            sudo mv /tmp/keploy /usr/local/bin/keploy
            keploy --version
      
      - run:
          name: Run Keploy Mock Test
          command: |
            keploy mock test --command "%s" --mockPath "%s"
          environment:
            CI: true

workflows:
  version: 2
  keploy-mock-test-workflow:
    jobs:
      - keploy-mock-test:
          filters:
            branches:
              only:
                - %s
                - /^(pull|merge)\/.*$/
`,
		config.DefaultBranch,
		config.AppCommand,
		config.MockPath,
		config.DefaultBranch,
	)
}

// generateAzurePipeline generates an Azure Pipelines configuration for Keploy mock testing.
func generateAzurePipeline(config PipelineConfig) string {
	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool

trigger:
  branches:
    include:
      - %s

pr:
  branches:
    include:
      - %s

pool:
  vmImage: 'ubuntu-latest'

variables:
  KEPLOY_MOCK_PATH: '%s'
  APP_COMMAND: '%s'

steps:
  - checkout: self
    displayName: 'Checkout code'

  - script: |
      curl --silent --location "https://github.com/keploy/keploy/releases/latest/download/keploy_linux_amd64.tar.gz" | tar xz -C /tmp
      sudo mv /tmp/keploy /usr/local/bin/keploy
      keploy --version
    displayName: 'Setup Keploy'

  - script: |
      keploy mock test --command "$(APP_COMMAND)" --mockPath "$(KEPLOY_MOCK_PATH)"
    displayName: 'Run Keploy Mock Test'
    env:
      CI: true
`,
		config.DefaultBranch,
		config.DefaultBranch,
		config.DefaultBranch,
		config.MockPath,
		config.AppCommand,
	)
}

// generateBitbucketPipeline generates a Bitbucket Pipelines configuration for Keploy mock testing.
func generateBitbucketPipeline(config PipelineConfig) string {
	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool

image: ubuntu:22.04

definitions:
  steps:
    - step: &keploy-mock-test
        name: Keploy Mock Test
        script:
          - apt-get update && apt-get install -y curl tar
          - curl --silent --location "https://github.com/keploy/keploy/releases/latest/download/keploy_linux_amd64.tar.gz" | tar xz -C /tmp
          - mv /tmp/keploy /usr/local/bin/keploy
          - keploy --version
          - keploy mock test --command "%s" --mockPath "%s"

pipelines:
  pull-requests:
    '**':
      - step: *keploy-mock-test

  branches:
    %s:
      - step: *keploy-mock-test
`,
		config.DefaultBranch,
		config.AppCommand,
		config.MockPath,
		config.DefaultBranch,
	)
}

// =============================================================================
// Enhanced Templates with Language-Specific Setup Steps
// =============================================================================

// generateGitHubActionsWorkflowWithSetup generates a GitHub Actions workflow with project-specific setup.
func generateGitHubActionsWorkflowWithSetup(config PipelineConfig, projectInfo ProjectInfo) string {
	setupSteps := generateGitHubActionsSetupSteps(projectInfo)
	dependencySteps := generateGitHubActionsDependencySteps(projectInfo)

	return fmt.Sprintf(`# Keploy Mock Test Workflow
# This workflow runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool
# Detected: %s project with %s
#
# Mock Path: %s
# Note: This path should point to the specific mock set directory created during
# 'keploy mock record'. Update if using a different mock set.

name: Keploy Mock Test

on:
  pull_request:
    branches: [%s]
  push:
    branches: [%s]

jobs:
  keploy-mock-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
%s%s
      - name: Install Keploy
        run: |
          curl --silent -O -L https://keploy.io/install.sh && source install.sh

      - name: Run Keploy Mock Test
        run: |
          keploy mock test -c "%s" --mockPath "%s"
        env:
          CI: true
`,
		config.DefaultBranch,
		projectInfo.Language,
		projectInfo.PackageManager,
		config.MockPath,
		config.DefaultBranch,
		config.DefaultBranch,
		setupSteps,
		dependencySteps,
		config.AppCommand,
		config.MockPath,
	)
}

// generateGitHubActionsSetupSteps generates the language runtime setup steps for GitHub Actions.
func generateGitHubActionsSetupSteps(projectInfo ProjectInfo) string {
	if projectInfo.Language == "" {
		return ""
	}

	switch projectInfo.Language {
	case "go":
		return fmt.Sprintf(`
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '%s'
`, projectInfo.RuntimeVersion)
	case "node":
		return fmt.Sprintf(`
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '%s'
          cache: '%s'
`, projectInfo.RuntimeVersion, projectInfo.PackageManager)
	case "python":
		return fmt.Sprintf(`
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '%s'
`, projectInfo.RuntimeVersion)
	case "java":
		return fmt.Sprintf(`
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '%s'
`, projectInfo.RuntimeVersion)
	case "ruby":
		return fmt.Sprintf(`
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '%s'
          bundler-cache: true
`, projectInfo.RuntimeVersion)
	case "rust":
		return `
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
`
	default:
		return ""
	}
}

// generateGitHubActionsDependencySteps generates the dependency installation steps for GitHub Actions.
func generateGitHubActionsDependencySteps(projectInfo ProjectInfo) string {
	if len(projectInfo.SetupSteps) == 0 {
		return ""
	}

	steps := "\n      - name: Install dependencies\n        run: |\n"
	for _, step := range projectInfo.SetupSteps {
		steps += fmt.Sprintf("          %s\n", step)
	}
	return steps
}

// generateGitLabCIPipelineWithSetup generates a GitLab CI pipeline with project-specific setup.
func generateGitLabCIPipelineWithSetup(config PipelineConfig, projectInfo ProjectInfo) string {
	image := getGitLabImage(projectInfo)
	beforeScript := generateGitLabBeforeScript(projectInfo)

	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on merge requests and merges to %s
# Generated by Keploy MCP Tool
# Detected: %s project with %s

stages:
  - test

variables:
  KEPLOY_MOCK_PATH: "%s"
  APP_COMMAND: "%s"

keploy-mock-test:
  stage: test
  image: %s
  
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "%s"
  
  before_script:
%s
    # Install Keploy
    - curl --silent -O -L https://keploy.io/install.sh && source install.sh
  
  script:
    - keploy mock test -c "${APP_COMMAND}" --mockPath "${KEPLOY_MOCK_PATH}"
`,
		config.DefaultBranch,
		projectInfo.Language,
		projectInfo.PackageManager,
		config.MockPath,
		config.AppCommand,
		image,
		config.DefaultBranch,
		beforeScript,
	)
}

// getGitLabImage returns the appropriate Docker image for the language.
func getGitLabImage(projectInfo ProjectInfo) string {
	switch projectInfo.Language {
	case "go":
		return fmt.Sprintf("golang:%s", projectInfo.RuntimeVersion)
	case "node":
		return fmt.Sprintf("node:%s", projectInfo.RuntimeVersion)
	case "python":
		return fmt.Sprintf("python:%s", projectInfo.RuntimeVersion)
	case "java":
		return fmt.Sprintf("eclipse-temurin:%s", projectInfo.RuntimeVersion)
	case "ruby":
		return fmt.Sprintf("ruby:%s", projectInfo.RuntimeVersion)
	case "rust":
		return "rust:latest"
	default:
		return "ubuntu:22.04"
	}
}

// generateGitLabBeforeScript generates the before_script section for GitLab CI.
func generateGitLabBeforeScript(projectInfo ProjectInfo) string {
	var lines []string

	// Add apt-get for tools if needed
	if projectInfo.Language == "" {
		lines = append(lines, "    - apt-get update && apt-get install -y curl tar")
	}

	// Add dependency installation steps
	for _, step := range projectInfo.SetupSteps {
		lines = append(lines, fmt.Sprintf("    - %s", step))
	}

	if len(lines) == 0 {
		return "    - echo 'Setting up environment...'"
	}

	return strings.Join(lines, "\n")
}

// generateJenkinsfileWithSetup generates a Jenkinsfile with project-specific setup.
func generateJenkinsfileWithSetup(config PipelineConfig, projectInfo ProjectInfo) string {
	toolsSection := generateJenkinsToolsSection(projectInfo)
	dependencyStage := generateJenkinsDependencyStage(projectInfo)

	return fmt.Sprintf(`// Keploy Mock Test Pipeline
// This pipeline runs Keploy mock tests on pull requests and merges to %s
// Generated by Keploy MCP Tool
// Detected: %s project with %s

pipeline {
    agent any
%s
    environment {
        KEPLOY_MOCK_PATH = '%s'
        APP_COMMAND = '%s'
    }

    triggers {
        pollSCM('H/5 * * * *')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
%s
        stage('Setup Keploy') {
            steps {
                sh '''
                    curl --silent -O -L https://keploy.io/install.sh && source install.sh
                '''
            }
        }

        stage('Keploy Mock Test') {
            steps {
                sh '''
                    keploy mock test -c "${APP_COMMAND}" --mockPath "${KEPLOY_MOCK_PATH}"
                '''
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}
`,
		config.DefaultBranch,
		projectInfo.Language,
		projectInfo.PackageManager,
		toolsSection,
		config.MockPath,
		config.AppCommand,
		dependencyStage,
	)
}

// generateJenkinsToolsSection generates the tools section for Jenkins.
func generateJenkinsToolsSection(projectInfo ProjectInfo) string {
	switch projectInfo.Language {
	case "go":
		return fmt.Sprintf(`
    tools {
        go 'go-%s'
    }
`, projectInfo.RuntimeVersion)
	case "node":
		return fmt.Sprintf(`
    tools {
        nodejs 'node-%s'
    }
`, projectInfo.RuntimeVersion)
	case "java":
		return fmt.Sprintf(`
    tools {
        jdk 'jdk-%s'
        maven 'maven-3'
    }
`, projectInfo.RuntimeVersion)
	default:
		return ""
	}
}

// generateJenkinsDependencyStage generates the dependency installation stage for Jenkins.
func generateJenkinsDependencyStage(projectInfo ProjectInfo) string {
	if len(projectInfo.SetupSteps) == 0 {
		return ""
	}

	steps := ""
	for _, step := range projectInfo.SetupSteps {
		steps += fmt.Sprintf("                    %s\n", step)
	}

	return fmt.Sprintf(`
        stage('Install Dependencies') {
            steps {
                sh '''
%s                '''
            }
        }
`, steps)
}

// generateCircleCIConfigWithSetup generates a CircleCI config with project-specific setup.
func generateCircleCIConfigWithSetup(config PipelineConfig, projectInfo ProjectInfo) string {
	image := getCircleCIImage(projectInfo)
	dependencySteps := generateCircleCIDependencySteps(projectInfo)

	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool
# Detected: %s project with %s

version: 2.1

executors:
  default:
    docker:
      - image: %s
    working_directory: ~/project

jobs:
  keploy-mock-test:
    executor: default
    steps:
      - checkout
%s
      - run:
          name: Install Keploy
          command: |
            curl --silent -O -L https://keploy.io/install.sh && source install.sh
      
      - run:
          name: Run Keploy Mock Test
          command: |
            keploy mock test -c "%s" --mockPath "%s"
          environment:
            CI: true

workflows:
  version: 2
  keploy-mock-test-workflow:
    jobs:
      - keploy-mock-test:
          filters:
            branches:
              only:
                - %s
                - /^(pull|merge)\/.*$/
`,
		config.DefaultBranch,
		projectInfo.Language,
		projectInfo.PackageManager,
		image,
		dependencySteps,
		config.AppCommand,
		config.MockPath,
		config.DefaultBranch,
	)
}

// getCircleCIImage returns the appropriate Docker image for CircleCI.
func getCircleCIImage(projectInfo ProjectInfo) string {
	switch projectInfo.Language {
	case "go":
		return fmt.Sprintf("cimg/go:%s", projectInfo.RuntimeVersion)
	case "node":
		return fmt.Sprintf("cimg/node:%s", projectInfo.RuntimeVersion)
	case "python":
		return fmt.Sprintf("cimg/python:%s", projectInfo.RuntimeVersion)
	case "java":
		return fmt.Sprintf("cimg/openjdk:%s", projectInfo.RuntimeVersion)
	case "ruby":
		return fmt.Sprintf("cimg/ruby:%s", projectInfo.RuntimeVersion)
	case "rust":
		return "cimg/rust:latest"
	default:
		return "cimg/base:current"
	}
}

// generateCircleCIDependencySteps generates dependency installation steps for CircleCI.
func generateCircleCIDependencySteps(projectInfo ProjectInfo) string {
	if len(projectInfo.SetupSteps) == 0 {
		return ""
	}

	steps := "\n      - run:\n          name: Install dependencies\n          command: |\n"
	for _, step := range projectInfo.SetupSteps {
		steps += fmt.Sprintf("            %s\n", step)
	}
	return steps
}

// generateAzurePipelineWithSetup generates an Azure Pipeline with project-specific setup.
func generateAzurePipelineWithSetup(config PipelineConfig, projectInfo ProjectInfo) string {
	setupSteps := generateAzurePipelineSetupSteps(projectInfo)
	dependencySteps := generateAzurePipelineDependencySteps(projectInfo)

	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool
# Detected: %s project with %s

trigger:
  branches:
    include:
      - %s

pr:
  branches:
    include:
      - %s

pool:
  vmImage: 'ubuntu-latest'

variables:
  KEPLOY_MOCK_PATH: '%s'
  APP_COMMAND: '%s'

steps:
  - checkout: self
    displayName: 'Checkout code'
%s%s
  - script: |
      curl --silent -O -L https://keploy.io/install.sh && source install.sh
    displayName: 'Install Keploy'

  - script: |
      keploy mock test -c "$(APP_COMMAND)" --mockPath "$(KEPLOY_MOCK_PATH)"
    displayName: 'Run Keploy Mock Test'
    env:
      CI: true
`,
		config.DefaultBranch,
		projectInfo.Language,
		projectInfo.PackageManager,
		config.DefaultBranch,
		config.DefaultBranch,
		config.MockPath,
		config.AppCommand,
		setupSteps,
		dependencySteps,
	)
}

// generateAzurePipelineSetupSteps generates language setup steps for Azure Pipelines.
func generateAzurePipelineSetupSteps(projectInfo ProjectInfo) string {
	if projectInfo.Language == "" {
		return ""
	}

	switch projectInfo.Language {
	case "go":
		return fmt.Sprintf(`
  - task: GoTool@0
    inputs:
      version: '%s'
    displayName: 'Setup Go'
`, projectInfo.RuntimeVersion)
	case "node":
		return fmt.Sprintf(`
  - task: NodeTool@0
    inputs:
      versionSpec: '%s'
    displayName: 'Setup Node.js'
`, projectInfo.RuntimeVersion)
	case "python":
		return fmt.Sprintf(`
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '%s'
    displayName: 'Setup Python'
`, projectInfo.RuntimeVersion)
	case "java":
		return fmt.Sprintf(`
  - task: JavaToolInstaller@0
    inputs:
      versionSpec: '%s'
      jdkArchitectureOption: 'x64'
      jdkSourceOption: 'PreInstalled'
    displayName: 'Setup Java'
`, projectInfo.RuntimeVersion)
	default:
		return ""
	}
}

// generateAzurePipelineDependencySteps generates dependency steps for Azure Pipelines.
func generateAzurePipelineDependencySteps(projectInfo ProjectInfo) string {
	if len(projectInfo.SetupSteps) == 0 {
		return ""
	}

	steps := "\n  - script: |\n"
	for _, step := range projectInfo.SetupSteps {
		steps += fmt.Sprintf("      %s\n", step)
	}
	steps += "    displayName: 'Install dependencies'\n"
	return steps
}

// generateBitbucketPipelineWithSetup generates a Bitbucket Pipeline with project-specific setup.
func generateBitbucketPipelineWithSetup(config PipelineConfig, projectInfo ProjectInfo) string {
	image := getBitbucketImage(projectInfo)
	dependencyScript := generateBitbucketDependencyScript(projectInfo)

	return fmt.Sprintf(`# Keploy Mock Test Pipeline
# This pipeline runs Keploy mock tests on pull requests and merges to %s
# Generated by Keploy MCP Tool
# Detected: %s project with %s

image: %s

definitions:
  steps:
    - step: &keploy-mock-test
        name: Keploy Mock Test
        script:
%s
          # Install Keploy
          - curl --silent -O -L https://keploy.io/install.sh && source install.sh
          # Run Keploy Mock Test
          - keploy mock test -c "%s" --mockPath "%s"

pipelines:
  pull-requests:
    '**':
      - step: *keploy-mock-test

  branches:
    %s:
      - step: *keploy-mock-test
`,
		config.DefaultBranch,
		projectInfo.Language,
		projectInfo.PackageManager,
		image,
		dependencyScript,
		config.AppCommand,
		config.MockPath,
		config.DefaultBranch,
	)
}

// getBitbucketImage returns the appropriate Docker image for Bitbucket Pipelines.
func getBitbucketImage(projectInfo ProjectInfo) string {
	switch projectInfo.Language {
	case "go":
		return fmt.Sprintf("golang:%s", projectInfo.RuntimeVersion)
	case "node":
		return fmt.Sprintf("node:%s", projectInfo.RuntimeVersion)
	case "python":
		return fmt.Sprintf("python:%s", projectInfo.RuntimeVersion)
	case "java":
		return fmt.Sprintf("eclipse-temurin:%s", projectInfo.RuntimeVersion)
	case "ruby":
		return fmt.Sprintf("ruby:%s", projectInfo.RuntimeVersion)
	case "rust":
		return "rust:latest"
	default:
		return "ubuntu:22.04"
	}
}

// generateBitbucketDependencyScript generates the dependency installation script for Bitbucket.
func generateBitbucketDependencyScript(projectInfo ProjectInfo) string {
	var lines []string

	// Add apt-get for basic tools if no language detected
	if projectInfo.Language == "" {
		lines = append(lines, "          - apt-get update && apt-get install -y curl tar")
	}

	// Add dependency installation steps
	for _, step := range projectInfo.SetupSteps {
		lines = append(lines, fmt.Sprintf("          - %s", step))
	}

	if len(lines) == 0 {
		return "          - echo 'Setting up environment...'"
	}

	return strings.Join(lines, "\n")
}
