package utils

import (
	"net/http/httptest"
	"testing"

	"context"
	"errors"

	"github.com/stretchr/testify/assert"
	"go.keploy.io/server/v2/config"
	keployModels "go.keploy.io/server/v2/pkg/models"
	"go.uber.org/zap"
	"go.uber.org/zap/zaptest"
	"go.uber.org/zap/zaptest/observer"
)

// TestGetVersionAsComment_ValidVersion_123 tests the behavior of GetVersionAsComment when the Version variable is set.
func TestGetVersionAsComment_ValidVersion_123(t *testing.T) {
	// Arrange
	Version = "1.0.0"
	expected := "# Generated by Keploy (1.0.0)\n"

	// Act
	result := GetVersionAsComment()

	// Assert
	assert.Equal(t, expected, result)
}

// TestReplaceHost_Cases_567 tests the ReplaceHost function for various scenarios.
func TestReplaceHost_Cases_567(t *testing.T) {
	t.Run("successful replacement", func(t *testing.T) {
		newURL, err := ReplaceHost("http://example.com/path", "127.0.0.1")
		assert.NoError(t, err)
		assert.Equal(t, "http://127.0.0.1/path", newURL)
	})

	t.Run("invalid url", func(t *testing.T) {
		newURL, err := ReplaceHost(":", "127.0.0.1")
		assert.Error(t, err)
		assert.Equal(t, ":", newURL)
	})

	t.Run("empty ip address", func(t *testing.T) {
		newURL, err := ReplaceHost("http://example.com/path", "")
		assert.Error(t, err)
		assert.Equal(t, "http://example.com/path", newURL)
	})
}

// TestURLManipulation_AllCases_842 tests URL manipulation functions.
func TestURLManipulation_AllCases_842(t *testing.T) {
	t.Run("ReplaceBaseURL", func(t *testing.T) {
		t.Run("success", func(t *testing.T) {
			res, err := ReplaceBaseURL("http://old.com/path", "https://new.com")
			assert.NoError(t, err)
			assert.Equal(t, "https://new.com/path", res)
		})
		t.Run("invalid current url", func(t *testing.T) {
			_, err := ReplaceBaseURL(":", "https://new.com")
			assert.Error(t, err)
		})
		t.Run("empty base url", func(t *testing.T) {
			_, err := ReplaceBaseURL("http://old.com/path", "")
			assert.Error(t, err)
		})
		t.Run("invalid base url", func(t *testing.T) {
			_, err := ReplaceBaseURL("http://old.com/path", ":")
			assert.Error(t, err)
		})
	})
	t.Run("ReplacePort", func(t *testing.T) {
		t.Run("success with existing port", func(t *testing.T) {
			res, err := ReplacePort("http://example.com:8080/path", "9090")
			assert.NoError(t, err)
			assert.Equal(t, "http://example.com:9090/path", res)
		})
		t.Run("success without existing port", func(t *testing.T) {
			res, err := ReplacePort("http://example.com/path", "9090")
			assert.NoError(t, err)
			assert.Equal(t, "http://example.com:9090/path", res)
		})
		t.Run("empty port", func(t *testing.T) {
			_, err := ReplacePort("http://example.com/path", "")
			assert.Error(t, err)
		})
		t.Run("invalid url", func(t *testing.T) {
			_, err := ReplacePort(":", "9090")
			assert.Error(t, err)
		})
	})
}

// TestGetReqMeta_AllCases_222 tests GetReqMeta for nil and non-nil requests.
func TestGetReqMeta_AllCases_222(t *testing.T) {
	t.Run("nil request", func(t *testing.T) {
		meta := GetReqMeta(nil)
		assert.Empty(t, meta)
	})
	t.Run("valid request", func(t *testing.T) {
		req := httptest.NewRequest("GET", "/test", nil)
		req.Host = "example.com"
		meta := GetReqMeta(req)
		assert.Equal(t, "GET", meta["method"])
		assert.Equal(t, "/test", meta["url"])
		assert.Equal(t, "example.com", meta["host"])
	})
}

// TestKebabToCamel_Simple_123 tests the kebabToCamel function.
func TestKebabToCamel_Simple_123(t *testing.T) {
	assert.Equal(t, "kebabCase", kebabToCamel("kebab-case"))
	assert.Equal(t, "single", kebabToCamel("single"))
	assert.Equal(t, "", kebabToCamel(""))
}

// TestRemoveDoubleQuotes_Simple_631 tests the RemoveDoubleQuotes function.
func TestRemoveDoubleQuotes_Simple_631(t *testing.T) {
	m := map[string]interface{}{
		"key1": `"value"`,
		"key2": `no-quotes`,
		"key3": 123,
	}
	RemoveDoubleQuotes(m)
	assert.Equal(t, "value", m["key1"])
	assert.Equal(t, "no-quotes", m["key2"])
	assert.Equal(t, 123, m["key3"])
}

// TestFindDockerCmd_AllCases_114 tests the FindDockerCmd function.
func TestFindDockerCmd_AllCases_114(t *testing.T) {
	testCases := []struct {
		cmd      string
		expected CmdType
	}{
		{"docker run -it ubuntu", DockerRun},
		{"sudo docker container start my-container", DockerStart},
		{"docker-compose up", DockerCompose},
		{"docker compose up", DockerCompose},
		{"./my-app", Native},
		{"", Empty},
	}

	for _, tc := range testCases {
		t.Run(tc.cmd, func(t *testing.T) {
			assert.Equal(t, tc.expected, FindDockerCmd(tc.cmd))
		})
	}
}

// TestTypeConversions_AllCases_825 tests type conversion utilities.
func TestTypeConversions_AllCases_825(t *testing.T) {
	t.Run("ToInt", func(t *testing.T) {
		assert.Equal(t, 123, ToInt("123"))
		assert.Equal(t, 456, ToInt(456))
		assert.Equal(t, 789, ToInt(789.0))
		assert.Equal(t, 0, ToInt("abc"))
		assert.Equal(t, 0, ToInt(nil))
	})
	t.Run("ToString", func(t *testing.T) {
		assert.Equal(t, "123", ToString(123))
		assert.Equal(t, "123.45", ToString(123.45))
		assert.Equal(t, "hello", ToString("hello"))
		assert.Equal(t, "", ToString(nil))
	})
	t.Run("ToFloat", func(t *testing.T) {
		assert.Equal(t, 123.45, ToFloat("123.45"))
		assert.Equal(t, 456.0, ToFloat(456))
		assert.Equal(t, 789.1, ToFloat(789.1))
		assert.Equal(t, 0.0, ToFloat("abc"))
		assert.Equal(t, 0.0, ToFloat(nil))
	})
}

// TestMiscUtilities_AllCases_991 tests various small utility functions.
func TestMiscUtilities_AllCases_991(t *testing.T) {
	t.Run("Keys", func(t *testing.T) {
		m := map[string][]string{"a": {}, "b": {}}
		keys := Keys(m)
		assert.ElementsMatch(t, []string{"a", "b"}, keys)
		assert.Empty(t, Keys(nil))
	})
	t.Run("EnsureRmBeforeName", func(t *testing.T) {
		assert.Equal(t, "docker run --rm --name c", EnsureRmBeforeName("docker run --name c"))
		assert.Equal(t, "docker run --rm --name c", EnsureRmBeforeName("docker run --rm --name c"))
		assert.Equal(t, "docker run", EnsureRmBeforeName("docker run"))
	})
	t.Run("IsDockerCmd", func(t *testing.T) {
		assert.True(t, IsDockerCmd(DockerRun))
		assert.True(t, IsDockerCmd(DockerStart))
		assert.True(t, IsDockerCmd(DockerCompose))
		assert.False(t, IsDockerCmd(Native))
		assert.False(t, IsDockerCmd(Empty))
	})
	t.Run("Hash", func(t *testing.T) {
		data := []byte("hello world")
		expectedHash := "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
		assert.Equal(t, expectedHash, Hash(data))
	})
}

// TestIsPassThrough_AllCases_777 tests the IsPassThrough logic with different bypass rules.
func TestIsPassThrough_AllCases_777(t *testing.T) {
	logger := zaptest.NewLogger(t)
	req := httptest.NewRequest("GET", "/api/v1/users", nil)
	req.Host = "example.com:8080"

	t.Run("pass on host match", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Host: "example\\.com.*"}},
		}
		assert.True(t, IsPassThrough(logger, req, 8080, opts))
	})

	t.Run("pass on path match", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Path: "/api/v1/.*"}},
		}
		assert.True(t, IsPassThrough(logger, req, 8080, opts))
	})

	t.Run("pass on host and port match", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Host: "example\\.com.*", Port: 8080}},
		}
		assert.True(t, IsPassThrough(logger, req, 8080, opts))
	})

	t.Run("no pass on port mismatch", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Host: "example\\.com.*", Port: 9090}},
		}
		assert.False(t, IsPassThrough(logger, req, 8080, opts))
	})

	t.Run("no pass on host mismatch", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Host: "test.com"}},
		}
		assert.False(t, IsPassThrough(logger, req, 8080, opts))
	})

	t.Run("invalid host regex", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Host: "["}},
		}
		assert.False(t, IsPassThrough(logger, req, 8080, opts))
	})

	t.Run("invalid path regex", func(t *testing.T) {
		opts := keployModels.OutgoingOptions{
			Rules: []config.BypassRule{{Path: "["}},
		}
		assert.False(t, IsPassThrough(logger, req, 8080, opts))
	})
}

// TestLogError_AllCases_482 tests the LogError function's behavior.
func TestLogError_AllCases_482(t *testing.T) {
	t.Run("nil logger", func(t *testing.T) {
		// Should not panic
		assert.NotPanics(t, func() {
			LogError(nil, errors.New("test"), "message")
		})
	})

	t.Run("context canceled error", func(t *testing.T) {
		logger, observer := observer.New(zap.InfoLevel)
		zlog := zap.New(logger)
		LogError(zlog, context.Canceled, "message")
		assert.Empty(t, observer.All())
	})

	t.Run("normal error", func(t *testing.T) {
		logger, observer := observer.New(zap.ErrorLevel)
		zlog := zap.New(logger)
		LogError(zlog, errors.New("test error"), "message")
		assert.Equal(t, 1, observer.Len())
		assert.Equal(t, "message", observer.All()[0].Message)
		assert.Equal(t, "test error", observer.All()[0].ContextMap()["error"])
	})
}

// TestIsXMLResponse_AllCases_567 tests the IsXMLResponse function.
func TestIsXMLResponse_AllCases_567(t *testing.T) {
	t.Run("application/xml", func(t *testing.T) {
		resp := &keployModels.HTTPResp{Header: map[string]string{"Content-Type": "application/xml"}}
		assert.True(t, IsXMLResponse(resp))
	})
	t.Run("text/xml with charset", func(t *testing.T) {
		resp := &keployModels.HTTPResp{Header: map[string]string{"Content-Type": "text/xml; charset=utf-8"}}
		assert.True(t, IsXMLResponse(resp))
	})
	t.Run("application/json", func(t *testing.T) {
		resp := &keployModels.HTTPResp{Header: map[string]string{"Content-Type": "application/json"}}
		assert.False(t, IsXMLResponse(resp))
	})
	t.Run("no content-type header", func(t *testing.T) {
		resp := &keployModels.HTTPResp{Header: map[string]string{"Other-Header": "value"}}
		assert.False(t, IsXMLResponse(resp))
	})
	t.Run("empty content-type header", func(t *testing.T) {
		resp := &keployModels.HTTPResp{Header: map[string]string{"Content-Type": ""}}
		assert.False(t, IsXMLResponse(resp))
	})
	t.Run("nil header", func(t *testing.T) {
		resp := &keployModels.HTTPResp{Header: nil}
		assert.False(t, IsXMLResponse(resp))
	})
	t.Run("nil response", func(t *testing.T) {
		assert.False(t, IsXMLResponse(nil))
	})
}
