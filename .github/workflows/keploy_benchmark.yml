name: Keploy Dynamic Test and Benchmark Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REPOS_SHEET_NAME: "repos"
  REPORT_SHEET_NAME: "benchmark_report"
  TIME_FORMAT_STRING: "%e,%P,%M"
  NOTIFICATION_RECIPIENT: "asish.kumar.programmer@gmail.com"
  KEPLOY_IMAGE_NAME: "ghcr.io/keploy/keploy:v2-dev"
  IMAGE_ARTIFACT_NAME: "keploy-docker-image"

jobs:
  build-keploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Keploy Source Code
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build Keploy Docker Image from Source
        run: sudo docker image build -t ${{ env.KEPLOY_IMAGE_NAME }} .
      - name: Save Docker image to a tar file
        run: sudo docker save -o keploy-image.tar ${{ env.KEPLOY_IMAGE_NAME }}
      - name: Change File Ownership
        run: sudo chown runner:runner keploy-image.tar
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.IMAGE_ARTIFACT_NAME }}
          path: keploy-image.tar
          retention-days: 1

  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.create-matrix.outputs.repos }}
    steps:
      - uses: actions/checkout@v4

      - uses: google-github-actions/setup-gcloud@v2
        with:
          version: ">= 463.0.0"

      - name: Activate service account
        id: gcloud-auth
        env:
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
        run: |
          echo "$GCP_SA_KEY" > sa.json
          gcloud auth activate-service-account --key-file=sa.json
          ACCESS_TOKEN=$(gcloud auth print-access-token --scopes=https://www.googleapis.com/auth/spreadsheets.readonly)
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "::error::Failed to mint access token"; exit 1
          fi
          echo "access_token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT

      - name: Get Repo List from Google Sheet via REST API
        id: get-repos
        env:
          TOKEN: ${{ steps.gcloud-auth.outputs.access_token }}
          SHEET_ID: ${{ secrets.SHEET_ID }}
          REPOS_SHEET_NAME: ${{ env.REPOS_SHEET_NAME }}
        run: |
          API_URL="https://sheets.googleapis.com/v4/spreadsheets/$SHEET_ID/values/${REPOS_SHEET_NAME}!A2:A"
          response=$(curl -s --fail --show-error --get "$API_URL" -H "Authorization: Bearer $TOKEN")
          echo "SHEET_VALUES<<EOF" >> $GITHUB_OUTPUT
          echo "$response" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create JSON Matrix from Sheet Data
        id: create-matrix
        env:
          SHEET_DATA: ${{ steps.get-repos.outputs.SHEET_VALUES }}
        run: |
          if echo "${SHEET_DATA}" | jq -e '.error' > /dev/null; then
            echo "::error::API call to Google Sheets failed. Full response below:"
            echo "${SHEET_DATA}"
            exit 1
          fi
          REPOS_JSON=$(echo "${SHEET_DATA}" | jq -c '(.values // []) | map(.[0])')
          echo "repos=${REPOS_JSON}" >> $GITHUB_OUTPUT

  test-and-benchmark:
    needs: [build-keploy, prepare-matrix]
    if: needs.prepare-matrix.outputs.repos != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.prepare-matrix.outputs.repos) }}
    steps:
      - name: Download Keploy Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.IMAGE_ARTIFACT_NAME }}

      - name: Load Keploy Docker image
        run: sudo docker load -i keploy-image.tar

      # Accept full URLs (https/ssh) OR owner/repo
      - name: Clone Application Repo
        run: |
          REPO="${{ matrix.repo }}"
          DEST="app"
          if [[ "$REPO" =~ ^https?:// ]] || [[ "$REPO" =~ ^git@ ]]; then
            git clone "$REPO" "$DEST"
          else
            git clone "https://github.com/$REPO.git" "$DEST"
          fi

      - name: Install yq (YAML Parser)
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Set up Language Environment
        id: language-setup
        run: |
          FOUND=$( (cd app && git ls-files | grep -E '(^|/)(keploy-pipeline\.yml|keploy\.ya?ml)$' | head -n1) )
          if [ -z "$FOUND" ]; then
            echo "language=none" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            echo "pipeline_file=" >> $GITHUB_OUTPUT
            exit 0
          fi
          PIPELINE_FILE="app/$FOUND"
          LANGUAGE=$(yq eval '.environment.language // "none"' "$PIPELINE_FILE")
          VERSION=$(yq eval '.environment.version // ""' "$PIPELINE_FILE")
          echo "language=$LANGUAGE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "pipeline_file=$PIPELINE_FILE" >> $GITHUB_OUTPUT

      - name: Setup Go
        if: steps.language-setup.outputs.language == 'go'
        uses: actions/setup-go@v5
        with:
          go-version: ${{ steps.language-setup.outputs.version }}

      - name: Setup Node.js
        if: steps.language-setup.outputs.language == 'node'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ steps.language-setup.outputs.version }}

      - name: Setup Python
        if: steps.language-setup.outputs.language == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ steps.language-setup.outputs.version }}

      - name: Run Pipeline from keploy-pipeline.yml
        id: pipeline-runner
        shell: bash
        run: |
          exec > >(tee runner-log.txt) 2>&1

          PIPELINE_FILE="${{ steps.language-setup.outputs.pipeline_file }}"
          if [ -z "$PIPELINE_FILE" ]; then
            echo "Failure reason: pipeline file not found (keploy-pipeline.yml / keploy.yml / keploy.yaml)"
            echo "final_status=Failed" >> $GITHUB_OUTPUT
            echo "failure_reason=pipeline file not found" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "Using pipeline file: $PIPELINE_FILE"

          FINAL_STATUS="Success"; FAILURE_REASON="None"
          REC_DURATION=0; REC_CPU_P="0%"; REC_MEM_MB=0
          TEST_DURATION=0; TEST_CPU_P="0%"; TEST_MEM_MB=0

          # Clean any stale container name
          sudo docker rm -f keploy-v2 >/dev/null 2>&1 || true

          # Base docker run line (IMPORTANT: use $PWD so it resolves AFTER 'cd app')
          KEPLOY_IMG="${{ env.KEPLOY_IMAGE_NAME }}"
          KBASE='sudo -E env PATH="$PATH" docker run --name keploy-v2 -p 16789:16789 --privileged --pid=host \
            -v "$PWD":"$PWD" -w "$PWD" \
            -v /sys/fs/cgroup:/sys/fs/cgroup -v /sys/kernel/debug:/sys/kernel/debug -v /sys/fs/bpf:/sys/fs/bpf \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v /usr/bin/docker:/usr/bin/docker:ro \
            -v /usr/lib/docker/cli-plugins:/usr/lib/docker/cli-plugins:ro \
            -v /usr/libexec/docker/cli-plugins:/usr/libexec/docker/cli-plugins:ro \
            -v "$HOME"/.keploy-config:/root/.keploy-config -v "$HOME"/.keploy:/root/.keploy \
            --rm'

          # Run Keploy (default entrypoint)
/bin/sh
          KEPLOY_RUN="$KBASE $KEPLOY_IMG"

          # Run an interactive shell INSIDE Keploy container (override entrypoint)
          KEPLOY_SH="$KBASE --entrypoint /bin/sh $KEPLOY_IMG -lc"

          echo "--- Running Setup Steps ---"
          yq eval '.setup // [] | .[]' "$PIPELINE_FILE" | while read -r cmd; do
            [ -z "$cmd" ] && continue
            cmd=${cmd//'docker-compose'/'docker compose'}
            echo "\$ $cmd"
            if ! (cd app && sudo -E bash -lc "$cmd"); then
              FINAL_STATUS="Failed"; FAILURE_REASON="Setup cmd failed: $cmd"; break
            fi
          done

          # --- Preflight: ensure docker + compose are usable inside Keploy container ---
          echo "--- Preflight: Docker/Compose inside Keploy container ---"
          (cd app && eval "$KEPLOY_SH 'docker version && docker compose version'") || {
            echo "::error::Docker/Compose not available inside Keploy container"
            echo "final_status=Failed" >> $GITHUB_OUTPUT
            echo "failure_reason=Docker/Compose unavailable inside Keploy container" >> $GITHUB_OUTPUT
            exit 1
          }

          # RECORD (optional but recommended)
          if [ "$FINAL_STATUS" = "Success" ]; then
            RECORD_CMD=$(yq eval '.record_command // ""' "$PIPELINE_FILE")
            if [ -n "$RECORD_CMD" ]; then
              RECORD_CMD=${RECORD_CMD//'docker-compose'/'docker compose'}
              if ! grep -q -- "--cmd-type" <<< "$RECORD_CMD"; then
                RECORD_CMD="$RECORD_CMD --cmd-type docker-compose"
              fi
              echo "--- Running Record Step ---"
              sudo -E bash -lc '
                set -e
                trap "kill -2 $KEPLOY_PID 2>/dev/null || true; wait $KEPLOY_PID || true" EXIT
                echo ">> cd app && eval \"$KEPLOY_RUN\" '"$RECORD_CMD"'"
                (cd app && eval "$KEPLOY_RUN" '"$RECORD_CMD"') &
                KEPLOY_PID=$!
                echo "Keploy record PID: $KEPLOY_PID"

                echo "Waiting for app container: fastapi-app (timeout 90s)..."
                for i in {1..30}; do
                  if docker ps --filter "name=fastapi-app" --filter "status=running" -q | grep -q .; then
                    echo "fastapi-app is running."
                    break
                  fi
                  sleep 3
                  if [ $i -eq 30 ]; then
                    echo "App container did not become running in time."
                    echo "---- docker compose ps ----"
                    (cd app && docker compose ps || true)
                    echo "---- fastapi-app logs (last 200) ----"
                    docker logs fastapi-app --tail=200 || true
                    exit 1
                  fi
                done

                if [ -f "app/curls.sh" ]; then
                  chmod +x app/curls.sh
                  echo "Executing app/curls.sh ..."
                  (cd app && ./curls.sh)
                else
                  echo "::warning::app/curls.sh not found; continuing without traffic"
                fi

                echo "Cooling down 10s..."
                sleep 10
                echo "Stopping Keploy..."
                kill -2 $KEPLOY_PID 2>/dev/null || true
                wait $KEPLOY_PID || true
                trap - EXIT
              ' || { FINAL_STATUS="Failed"; FAILURE_REASON="Record orchestration failed (compose/app didn’t start)"; }
            else
              echo "::warning::record_command not defined; skipping record phase"
            fi
          fi

          # TEST
          if [ "$FINAL_STATUS" = "Success" ]; then
            TEST_CMD=$(yq eval '.test_command // ""' "$PIPELINE_FILE")
            if [ -n "$TEST_CMD" ]; then
              TEST_CMD=${TEST_CMD//'docker-compose'/'docker compose'}
              echo "--- Running Test Step ---"
              echo ">> cd app && eval \"$KEPLOY_RUN\" $TEST_CMD"
              if sudo /usr/bin/time -f "${{ env.TIME_FORMAT_STRING }}" -o test_metrics.csv bash -lc "cd app && eval \"$KEPLOY_RUN\" $TEST_CMD"; then
                IFS=',' read TEST_E TEST_P TEST_M < test_metrics.csv
                TEST_DURATION=$TEST_E; TEST_CPU_P=$TEST_P; TEST_MEM_MB=$(echo "scale=2; $TEST_M / 1024" | bc)
              else
                echo "---- docker compose ps (after test failure) ----"
                (cd app && docker compose ps || true)
                echo "---- fastapi-app logs (last 200) ----"
                docker logs fastapi-app --tail=200 || true
                FINAL_STATUS="Failed"; FAILURE_REASON="Test step failed (likely no test-sets recorded)"
              fi
            else
              FINAL_STATUS="Failed"; FAILURE_REASON="test_command not defined"
            fi
          fi

          echo "Failure reason: $FAILURE_REASON"
          echo "final_status=$FINAL_STATUS" >> $GITHUB_OUTPUT
          echo "failure_reason=$FAILURE_REASON" >> $GITHUB_OUTPUT
          echo "rec_duration=$REC_DURATION" >> $GITHUB_OUTPUT
          echo "rec_cpu_p=$REC_CPU_P" >> $GITHUB_OUTPUT
          echo "rec_mem_mb=$REC_MEM_MB" >> $GITHUB_OUTPUT
          echo "test_duration=$TEST_DURATION" >> $GITHUB_OUTPUT
          echo "test_cpu_p=$TEST_CPU_P" >> $GITHUB_OUTPUT
          echo "test_mem_mb=$TEST_MEM_MB" >> $GITHUB_OUTPUT

          if [ "$FINAL_STATUS" != "Success" ]; then exit 1; fi

      - name: Create Report Data as Artifact
        if: always()
        run: |
          TIMESTAMP_IST=$(TZ='Asia/Kolkata' date +'%b %d, %Y, %I:%M %p %Z')
          WORKFLOW_LINK="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          FINAL_STATUS="${{ steps.pipeline-runner.outputs.final_status }}"
          FAILURE_REASON="${{ steps.pipeline-runner.outputs.failure_reason }}"
          REC_DUR=${{ steps.pipeline-runner.outputs.rec_duration || 0 }}
          REC_CPU_P="${{ steps.pipeline-runner.outputs.rec_cpu_p || '0%' }}"
          REC_MEM_MB=${{ steps.pipeline-runner.outputs.rec_mem_mb || 0 }}
          TEST_DUR=${{ steps.pipeline-runner.outputs.test_duration || 0 }}
          TEST_CPU_P="${{ steps.pipeline-runner.outputs.test_cpu_p || '0%' }}"
          TEST_MEM_MB=${{ steps.pipeline-runner.outputs.test_mem_mb || 0 }}
          JSON_ROW=$(jq -n \
            --arg ts "$TIMESTAMP_IST" \
            --arg wlink "$WORKFLOW_LINK" \
            --arg rurl "${{ matrix.repo }}" \
            --arg status "$FINAL_STATUS" \
            --arg reason "$FAILURE_REASON" \
            --argjson recdur $REC_DUR \
            --arg reccpup "$REC_CPU_P" \
            --argjson recmem $REC_MEM_MB \
            --argjson testdur $TEST_DUR \
            --arg testcpup "$TEST_CPU_P" \
            --argjson testmem $TEST_MEM_MB \
            '[[$ts, $wlink, $rurl, $status, $reason, $recdur, $reccpup, $recmem, $testdur, $testcpup, $testmem]]')
          echo "$JSON_ROW" > report.json

      - name: Sanitize artifact name
        id: safe-name
        if: always()
        run: |
          RAW="${{ matrix.repo }}"
          SAFE="$RAW"
          SAFE="${SAFE#https://}"; SAFE="${SAFE#http://}"; SAFE="${SAFE#git@}"
          SAFE="${SAFE//\//-}"; SAFE="${SAFE//:/-}"; SAFE="${SAFE//@/-}"; SAFE="${SAFE// /-}"
          SAFE=$(printf '%s' "$SAFE" | sed 's/[^A-Za-z0-9._-]/-/g')
          echo "safe=$SAFE" >> $GITHUB_OUTPUT

      - name: Upload Individual Report as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: report-for-${{ steps.safe-name.outputs.safe }}
          path: report.json

      - name: Prepare Attachments on Failure
        if: failure()
        run: |
          echo "Zipping Keploy directory for email attachment..."
          if [ -d "app/keploy" ]; then sudo zip -r keploy_artifacts.zip app/keploy; else echo "Keploy directory not found."; fi

      - name: Send Email Notification on Failure
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: "smtp.gmail.com"
          server_port: 587
          username: ${{ secrets.GMAIL_USERNAME }}
          password: ${{ secrets.GMAIL_APP_PASSWORD }}
          subject: "❌ CI Failure: Keploy Test Failed for ${{ matrix.repo }}"
          to: ${{ env.NOTIFICATION_RECIPIENT }}
          from: GitHub Actions CI <${{ secrets.GMAIL_USERNAME }}>
          body: |
            A failure occurred while running the Keploy test pipeline.
            **Repository:** `${{ matrix.repo }}`
            **Failure Reason:** `${{ steps.pipeline-runner.outputs.failure_reason }}`
            **Logs:** See runner-log.txt artifact.
            **Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          attachments: runner-log.txt, keploy_artifacts.zip

  report-to-google-sheets:
    runs-on: ubuntu-latest
    needs: test-and-benchmark
    if: always()
    steps:
      - name: Authenticate to Google Cloud
        id: auth
        uses: "google-github-actions/auth@v2"
        with:
          create_credentials_file: false
          credentials_json: "${{ secrets.GCP_SA_KEY }}"
          access_token_scopes: "https://www.googleapis.com/auth/spreadsheets"

      - name: Download all individual reports
        uses: actions/download-artifact@v4
        with:
          path: all-reports
          pattern: report-for-*
          merge-multiple: true

      - name: Aggregate all reports into a single payload
        id: aggregate
        run: |
          files=$(find all-reports -name "report.json" -type f)
          if [ -z "$files" ]; then 
            echo "payload=[]" >> $GITHUB_OUTPUT
          else 
            FINAL_PAYLOAD=$(jq -s 'map(.[0])' $files)
            echo "payload=${FINAL_PAYLOAD}" >> $GITHUB_OUTPUT
          fi

      - name: Append data to Google Sheet via REST API
        if: steps.aggregate.outputs.payload != '[]'
        run: |
          API_URL="https://sheets.googleapis.com/v4/spreadsheets/${{ secrets.SHEET_ID }}/values/${{ env.REPORT_SHEET_NAME }}:append?valueInputOption=USER_ENTERED"
          JSON_BODY=$(jq -n --argjson values "${{ steps.aggregate.outputs.payload }}" '{ "values": $values }')
          curl -s --request POST "$API_URL" \
               --header "Authorization: Bearer ${{ steps.auth.outputs.access_token }}" \
               --header "Content-Type: application/json" \
               --data-raw "$JSON_BODY"