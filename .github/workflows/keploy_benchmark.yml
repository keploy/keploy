name: Keploy Dynamic Test and Benchmark Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REPOS_SHEET_NAME: "repos"
  REPORT_SHEET_NAME: "benchmark_report"
  TIME_FORMAT_STRING: "%e,%P,%M"
  NOTIFICATION_RECIPIENT: "officialasishkumar@gmail.com"

jobs:
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.create-matrix.outputs.repos }}
    steps:
      - name: Authenticate to Google Cloud
        id: auth
        uses: "google-github-actions/auth@v2"
        with:
          credentials_json: "${{ secrets.GCP_SA_KEY }}"

      - name: Get Repo List from Google Sheet via REST API
        id: get-repos
        run: |
          API_URL="https://sheets.googleapis.com/v4/spreadsheets/${{ secrets.SHEET_ID }}/values/${{ env.REPOS_SHEET_NAME }}!A2:A"
          response=$(curl -s --request GET "$API_URL" --header "Authorization: Bearer ${{ steps.auth.outputs.access_token }}")
          echo "SHEET_VALUES<<EOF" >> $GITHUB_OUTPUT; echo "$response" >> $GITHUB_OUTPUT; echo "EOF" >> $GITHUB_OUTPUT

      - name: Create JSON Matrix from Sheet Data
        id: create-matrix
        run: |
          REPOS_JSON=$(echo "${{ steps.get-repos.outputs.SHEET_VALUES }}" | jq -c '.values | map(.[0])')
          echo "repos=${REPOS_JSON}" >> $GITHUB_OUTPUT

  build-keploy-from-source:
    # This new job builds the Keploy binary and Docker image from the source in this repo.
    # It runs before the main test job.
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Keploy Repository
        uses: actions/checkout@v4
        # This checks out the code of the repository where the workflow is running

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"

      - name: Set up Docker Buildx
        # This step explicitly prepares the Docker environment, as requested.
        uses: docker/setup-buildx-action@v3

      - name: Build Keploy Go Binary
        run: |
          echo "Building Keploy binary from source..."
          go build -race -tags=viper_bind_struct -o keploy . && sudo mv keploy /usr/local/bin
          echo "Keploy binary moved to /usr/local/bin"

      - name: Build Keploy Docker Image
        run: |
          echo "Building Keploy Docker image from source..."
          # The image is tagged with ':v2-dev' so the next job uses this local build.
          sudo docker image build -t ghcr.io/keploy/keploy:v2-dev .
          echo "Docker image built successfully."

  test-and-benchmark:
    # This job now depends on BOTH the matrix preparation AND the successful build of Keploy.
    needs: [prepare-matrix, build-keploy-from-source]
    if: needs.prepare-matrix.outputs.repos != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.prepare-matrix.outputs.repos) }}
    steps:
      - name: Checkout Application Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          path: "app"

      - name: Install yq (YAML Parser)
        run: sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq && sudo chmod +x /usr/bin/yq

      - name: Run Pipeline from keploy-pipeline.yml
        id: pipeline-runner
        run: |
          exec > >(tee runner-log.txt) 2>&1

          set -a 
          PIPELINE_FILE="app/keploy-pipeline.yml"
          FINAL_STATUS="Success"; FAILURE_REASON="None"
          REC_DURATION=0; REC_CPU_P="0%"; REC_MEM_MB=0; TEST_DURATION=0; TEST_CPU_P="0%"; TEST_MEM_MB=0

          # This function now uses the Docker image we built in the previous job
          # because it exists locally with the 'ghcr.io/keploy/keploy:v2-dev' tag.
          keployV2() {
            sudo -E env PATH="$PATH" docker run --name keploy-v2 -p 16789:16789 --privileged --pid=host -v "$(pwd)":"$(pwd)" -w "$(pwd)" -v /sys/fs/cgroup:/sys/fs/cgroup -v /sys/kernel/debug:/sys/kernel/debug -v /sys/fs/bpf:/sys/fs/bpf -v /var/run/docker.sock:/var/run/docker.sock -v "$HOME"/.keploy-config:/root/.keploy-config -v "$HOME"/.keploy:/root/.keploy --rm ghcr.io/keploy/keploy:v2-dev "$@"
          }

          if [ ! -f "$PIPELINE_FILE" ]; then
            FINAL_STATUS="Failed"; FAILURE_REASON="keploy-pipeline.yml not found"
          else
            APP_CMD=$(yq eval '.app_command' "$PIPELINE_FILE")
            TEST_DELAY=$(yq eval '.test_delay // 0' "$PIPELINE_FILE")

            echo "--- Running Setup Steps ---"; yq eval '.setup[]' "$PIPELINE_FILE" | while read -r cmd; do if ! (cd app && bash -c "$cmd"); then FINAL_STATUS="Failed"; FAILURE_REASON="Setup cmd failed: $cmd"; break; fi; done
            
            if [ "$FINAL_STATUS" == "Success" ]; then
              echo "--- Running Record Step ---"; 
              if [ "$APP_CMD" != "null" ]; then
                RECORD_CMD="keployV2 record -c \"$APP_CMD\""
                echo "Executing Record Command: $RECORD_CMD"
                /usr/bin/time -f "${{ env.TIME_FORMAT_STRING }}" -o record_metrics.csv (cd app && bash -c "$RECORD_CMD")
                if [ $? -eq 0 ]; then IFS=',' read REC_E REC_P REC_M < record_metrics.csv; REC_DURATION=$REC_E; REC_CPU_P=$REC_P; REC_MEM_MB=$(echo "scale=2; $REC_M / 1024" | bc); else FINAL_STATUS="Failed"; FAILURE_REASON="Record step failed"; fi
              else FINAL_STATUS="Failed"; FAILURE_REASON="app_command not defined in keploy-pipeline.yml"; fi
            fi

            if [ "$FINAL_STATUS" == "Success" ]; then
              echo "--- Running Test Step ---"; 
              if [ "$APP_CMD" != "null" ]; then
                TEST_CMD="keployV2 test -c \"$APP_CMD\" --delay $TEST_DELAY"
                echo "Executing Test Command: $TEST_CMD"
                /usr/bin/time -f "${{ env.TIME_FORMAT_STRING }}" -o test_metrics.csv (cd app && bash -c "$TEST_CMD")
                if [ $? -eq 0 ]; then IFS=',' read TEST_E TEST_P TEST_M < test_metrics.csv; TEST_DURATION=$TEST_E; TEST_CPU_P=$TEST_P; TEST_MEM_MB=$(echo "scale=2; $TEST_M / 1024" | bc); else FINAL_STATUS="Failed"; FAILURE_REASON="Test step failed"; fi
              else FINAL_STATUS="Failed"; FAILURE_REASON="app_command not defined in keploy-pipeline.yml"; fi
            fi
          fi

          echo "final_status=$FINAL_STATUS" >> $GITHUB_OUTPUT; echo "failure_reason=$FAILURE_REASON" >> $GITHUB_OUTPUT
          echo "rec_duration=$REC_DURATION" >> $GITHUB_OUTPUT; echo "rec_cpu_p=$REC_CPU_P" >> $GITHUB_OUTPUT; echo "rec_mem_mb=$REC_MEM_MB" >> $GITHUB_OUTPUT
          echo "test_duration=$TEST_DURATION" >> $GITHUB_OUTPUT; echo "test_cpu_p=$TEST_CPU_P" >> $GITHUB_OUTPUT; echo "test_mem_mb=$TEST_MEM_MB" >> $GITHUB_OUTPUT

          if [ "$FINAL_STATUS" != "Success" ]; then exit 1; fi

      - name: Create Report Data as Artifact
        if: always()
        run: |
          TIMESTAMP_IST=$(TZ='Asia/Kolkata' date +'%b %d, %Y, %I:%M %p %Z')
          WORKFLOW_LINK="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          FINAL_STATUS="${{ steps.pipeline-runner.outputs.final_status }}"; FAILURE_REASON="${{ steps.pipeline-runner.outputs.failure_reason }}"
          REC_DUR=${{ steps.pipeline-runner.outputs.rec_duration }}; REC_CPU_P="${{ steps.pipeline-runner.outputs.rec_cpu_p }}"; REC_MEM_MB=${{ steps.pipeline-runner.outputs.rec_mem_mb }}
          TEST_DUR=${{ steps.pipeline-runner.outputs.test_duration }}; TEST_CPU_P="${{ steps.pipeline-runner.outputs.test_cpu_p }}"; TEST_MEM_MB=${{ steps.pipeline-runner.outputs.test_mem_mb }}
          JSON_ROW=$(jq -n --arg ts "$TIMESTAMP_IST" --arg wlink "$WORKFLOW_LINK" --arg rurl "${{ matrix.repo }}" --arg status "$FINAL_STATUS" --arg reason "$FAILURE_REASON" --argjson recdur "$REC_DUR" --arg reccpup "$REC_CPU_P" --argjson recmem "$REC_MEM_MB" --argjson testdur "$TEST_DUR" --arg testcpup "$TEST_CPU_P" --argjson testmem "$TEST_MEM_MB" '[[$ts, $wlink, $rurl, $status, $reason, $recdur, $reccpup, $recmem, $testdur, $testcpup, $testmem]]')
          echo "$JSON_ROW" > report.json

      - name: Upload Individual Report as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: report-for-${{ matrix.repo }}
          path: report.json

      - name: Prepare Attachments on Failure
        if: failure()
        run: |
          echo "Zipping Keploy directory for email attachment..."
          if [ -d "app/keploy" ]; then
            zip -r keploy_artifacts.zip app/keploy
          else
            echo "Keploy directory not found. No archive will be created."
          fi

      - name: Send Email Notification on Failure
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: "smtp.gmail.com"
          server_port: 587
          username: ${{ secrets.GMAIL_USERNAME }}
          password: ${{ secrets.GMAIL_APP_PASSWORD }}
          subject: "‚ùå CI Failure: Keploy Test Failed for ${{ matrix.repo }}"
          to: ${{ env.NOTIFICATION_RECIPIENT }}
          from: GitHub Actions CI <${{ secrets.GMAIL_USERNAME }}>
          body: |
            A failure occurred while running the Keploy test pipeline.

            **Repository:** `${{ matrix.repo }}`
            **Failure Reason:** `${{ steps.pipeline-runner.outputs.failure_reason }}`

            Please review the attached logs and Keploy directory for details.

            **Direct Link to Failed Run:**
            ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          attachments: runner-log.txt, keploy_artifacts.zip

  report-to-google-sheets:
    runs-on: ubuntu-latest
    needs: test-and-benchmark
    if: always()
    steps:
      - name: Authenticate to Google Cloud
        id: auth
        uses: "google-github-actions/auth@v2"
        with:
          credentials_json: "${{ secrets.GCP_SA_KEY }}"

      - name: Download all individual reports
        uses: actions/upload-artifact@v4
        with:
          path: all-reports
          pattern: report-for-*
          merge-multiple: true

      - name: Aggregate all reports into a single payload
        id: aggregate
        run: |
          files=$(find all-reports -name "report.json" -type f)
          if [ -z "$files" ]; then
            echo "payload=[]" >> $GITHUB_OUTPUT
          else
            FINAL_PAYLOAD=$(jq -s 'map(.[0])' $files)
            echo "payload=${FINAL_PAYLOAD}" >> $GITHUB_OUTPUT
          fi

      - name: Append data to Google Sheet via REST API
        if: steps.aggregate.outputs.payload != '[]'
        run: |
          API_URL="https://sheets.googleapis.com/v4/spreadsheets/${{ secrets.SHEET_ID }}/values/${{ env.REPORT_SHEET_NAME }}:append?valueInputOption=USER_ENTERED"
          JSON_BODY=$(jq -n --argjson values "${{ steps.aggregate.outputs.payload }}" '{ "values": $values }')
          curl -s --request POST "$API_URL" --header "Authorization: Bearer ${{ steps.auth.outputs.access_token }}" --header "Content-Type: application/json" --data-raw "$JSON_BODY"
