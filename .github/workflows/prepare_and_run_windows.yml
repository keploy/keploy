name: Prepare Binary and Run Workflows (Windows)
on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  build-and-upload:
    if: ${{ (github.event_name == 'pull_request' && !github.event.pull_request.head.repo.fork) || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    runs-on: [self-hosted, Windows, X64]
    steps:
      # - name: Aggressive Cleanup (Workspace + Keploy procs)
      #   if: always()
      #   shell: powershell
      #   continue-on-error: true
      #   run: |
      #     # Kill any lingering Keploy processes
      #     $procs = 'keploy.exe','keploy-record.exe','keploy-replay.exe','keploy-record','keploy-replay'
      #     foreach ($p in $procs) { cmd /c "taskkill /F /IM $p /T" 2>$null | Out-Null }

      #     # Clean workspace artifacts that could affect the build
      #     $paths = @('.\bin','.\\keploy.exe','.\\keploy','.\\keploy.yml','.\\record-bin','.\\replay-bin')
      #     foreach ($p in $paths) {
      #       Remove-Item -LiteralPath $p -Recurse -Force -ErrorAction SilentlyContinue
      #     }

      #     # Optional: clean Go caches to avoid stale behavior
      #     go version 2>$null | Out-Null
      #     if ($LASTEXITCODE -eq 0) {
      #       go clean -cache -modcache -testcache -fuzzcache 2>$null
      #     }
      - name: Create workflow start lock
        shell: powershell
        run: |
          $lockDir = Join-Path $env:USERPROFILE '.github-workflow-locks'
          New-Item -Path $lockDir -ItemType Directory -Force | Out-Null
          $timestamp = (Get-Date -UFormat %s)
          $lockPath = Join-Path $lockDir "prepare-windows-workflow-$($env:GITHUB_RUN_ID).lock"
          Set-Content -Path $lockPath -Value "started-$timestamp"
          Write-Host "Created workflow start lock: $lockPath"

      - name: Clean up git config (ensure HTTPS for checkout)
        if: always()
        continue-on-error: true
        shell: powershell
        run: |
          git config --global --unset-all url."git@github.com:".insteadof  2>$null
          git config --global --unset-all url."ssh://git@github.com/".insteadof  2>$null
          git config --global --unset-all core.sshCommand  2>$null
          git config --global --list

      - name: Configure Git EOL on Windows
        shell: powershell
        run: |
          git config --global core.autocrlf false
          git config --global core.eol lf

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0
          clean: true

      - name: Build Keploy (PR) - Windows (windows/amd64)
        shell: powershell
        run: |
          $env:GOOS = "windows"
          $env:GOARCH = "amd64"
          $env:CGO_ENABLED = "0"
          go build -tags=viper_bind_struct -ldflags="-X main.version=${{ github.sha }}" -o keploy.exe ./main.go

      - name: Upload build artifact (Windows CLI)
        uses: actions/upload-artifact@v4
        with: 
          name: build
          path: keploy.exe

      - name: Clean up git config
        if: always()
        continue-on-error: true
        shell: powershell
        run: |
          git config --global --unset url."git@github.com:".insteadOf

  docker-image-build:
    if: ${{ (github.event_name == 'pull_request' && !github.event.pull_request.head.repo.fork) || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Add Private Parsers
        uses: ./.github/actions/setup-private-parsers
        with:
          ssh-private-key: ${{ secrets.INTEGRATIONS_REPO_DEPLOY_KEY_PRIVATE }}
          go-cache: true

      - name: Set PR image tag
        run: echo "PR_IMAGE_TAG=ttl.sh/keploy/keploy:${GITHUB_SHA::7}" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image for PR
        run: |
          source ./.github/workflows/test_workflow_scripts/update-docker-mac.sh

      - name: Make unique tag for this run
        id: tag
        run: |
          IMAGE_TAG="ttl.sh/keploy/keploy:${GITHUB_SHA}-1h"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          docker image inspect ttl.sh/keploy/keploy:1h > /dev/null
          docker tag ttl.sh/keploy/keploy:1h "$IMAGE_TAG"

      - name: Push unique tag
        run: |
          docker push "${{ steps.tag.outputs.image_tag }}"
    
  pull-docker-image:
    needs: [docker-image-build]
    if: ${{ (github.event_name == 'pull_request' && !github.event.pull_request.head.repo.fork) || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    runs-on: [self-hosted, Windows, X64]

    steps:
    - name: Check if Docker Desktop is running / If not then Start
      shell: powershell
      run: |
        function Test-Docker {
          # Check if Docker CLI exists at all
          $dockerCmd = Get-Command docker -ErrorAction SilentlyContinue
          if (-not $dockerCmd) {
            return $false
          }

          # Use Start-Process so failures don't raise a NativeCommandError in PowerShell
          try {
            $proc = Start-Process -FilePath $dockerCmd.Source -ArgumentList @('info','--format','{{.ServerVersion}}') -NoNewWindow -PassThru -Wait -ErrorAction SilentlyContinue
            if ($proc -and $proc.ExitCode -eq 0) { return $true }
            return $false
          } catch {
            return $false
          }
        }

        function Test-DockerDesktopProcess {
          $process = Get-Process -Name "Docker Desktop" -ErrorAction SilentlyContinue
          return $process -ne $null
        }

        if (Test-Docker) {
          Write-Host "âœ… Docker engine is already running."
        } else {
          if (Test-DockerDesktopProcess) {
            Write-Host "â³ Docker Desktop process found but engine not ready. Waiting..."
          } else {
            Write-Host "ðŸš€ Starting Docker Desktop..."
            Start-Process "C:\Program Files\Docker\Docker\Docker Desktop.exe" -WindowStyle Hidden
          }

          # Wait for Docker to become ready
          $timeout = (Get-Date).AddSeconds(90)
          while (-not (Test-Docker)) {
            if ((Get-Date) -gt $timeout) {
              Write-Error "âŒ Docker did not start within 90 seconds."
              exit 1
            }
            Start-Sleep -Seconds 3
          }

          Write-Host "âœ… Docker Desktop is now running and engine is ready."
          Write-Host "Waiting an additional 60 seconds for Docker to stabilize..."
          Start-Sleep -Seconds 60
        }

    - name: Pull Docker image
      shell: powershell
      run: |
        docker pull ${{ needs.docker-image-build.outputs.image_tag }}

  run_golang_docker_windows:
    needs: [build-and-upload, docker-image-build, pull-docker-image]
    uses: ./.github/workflows/golang_docker_windows.yml
    with:
      image_tag: ${{ needs.docker-image-build.outputs.image_tag }}

  cleanup:
    if: ${{ always() && ((github.event_name == 'pull_request' && !github.event.pull_request.head.repo.fork) || (github.event_name == 'push' && github.ref == 'refs/heads/main')) }}
    runs-on: [self-hosted, Windows, X64]
    needs: [run_golang_docker_windows]
    steps:
      - name: Remove workflow start lock
        shell: powershell
        run: |
          $lockDir = Join-Path $env:USERPROFILE '.github-workflow-locks'
          $lockPath = Join-Path $lockDir "prepare-windows-workflow-$($env:GITHUB_RUN_ID).lock"
          Remove-Item -Path $lockPath -Force -ErrorAction SilentlyContinue
    
      - name: Check if the count of lock files is zero (and stop long-running containers)
        shell: powershell
        run: |
          # Ensure we don't blow up on missing vars/paths
          $ErrorActionPreference = 'Stop'

          # 1) Resolve lock directory and lock files safely
          $lockDir = Join-Path $env:USERPROFILE '.github-workflow-locks'

          # Always initialize as an array so later checks don't hit null
          $lockFiles = @()
          if (Test-Path -LiteralPath $lockDir) {
            $lockFiles = Get-ChildItem -Path $lockDir -Filter '*.lock' -ErrorAction SilentlyContinue
          }

          # 2) Check if Docker is available
          $dockerCmd = Get-Command docker -ErrorAction SilentlyContinue
          if (-not $dockerCmd) {
            Write-Warning "Docker CLI not found on PATH. Skipping Docker cleanup."
            # You can 'return' here if this is a script file
            # return
          } else {
            # 3) Find containers running longer than 30 minutes and stop/remove them
            $stoppedAny = $false
            try {
              $cutoff = (Get-Date).AddMinutes(-30)

              # Force array so $running is never $null
              $running = @(docker ps -q 2>$null)

              if ($running.Count -gt 0) {
                Write-Host "Checking running containers for uptime > 30 minutes..."
                foreach ($cid in $running) {
                  if (-not $cid) { continue }

                  try {
                    # use double-quotes to avoid odd parsing, but nothing is interpolated here
                    $started = docker inspect --format "{{.State.StartedAt}}" $cid 2>$null
                    if (-not $started) { continue }

                    # Be tolerant of Z/UTC format
                    $startedDt = [DateTime]::Parse($started, $null, [System.Globalization.DateTimeStyles]::AssumeUniversal)

                    if ($startedDt -lt $cutoff) {
                      Write-Host "Container $cid started at $startedDt (older than 30m). Stopping and removing..."
                      try {
                        docker rm -f $cid 2>&1 | Write-Host
                        $stoppedAny = $true
                      } catch {
                        Write-Warning "Failed to remove container ${cid}: $($_.Exception.Message)"
                      }
                    }
                  } catch {
                    Write-Warning "Failed to inspect/parse start time for container ${cid}: $($_.Exception.Message)"
                  }
                }
              } else {
                Write-Host "No running containers found."
              }
            } catch {
              Write-Warning "Docker check for long-running containers failed: $($_.Exception.Message)"
            }

            # 4) Decide whether to prune
            $shouldPrune = $false

            if (-not $lockFiles -or $lockFiles.Count -eq 0) {
              Write-Host "No lock files found. Will perform Docker cleanup."

              if (Test-Path -LiteralPath $lockDir) {
                Remove-Item -Path $lockDir -Recurse -Force -ErrorAction SilentlyContinue
              }

              $shouldPrune = $true
            } elseif ($stoppedAny) {
              Write-Host "Stopped long-running containers. Will perform Docker cleanup despite lock files."
              $shouldPrune = $true
            } else {
              $count = $lockFiles.Count
              Write-Host "Lock files still present ($count). Skipping Docker cleanup."
            }

            # 5) Perform prune if needed
            if ($shouldPrune) {
              Write-Host "Pruning Docker images (this will remove dangling and unused images)..."
              try {
                docker image prune -af 2>&1 | Write-Host
              } catch {
                Write-Warning "docker image prune failed: $($_.Exception.Message)"
              }

              Write-Host "Pruning Docker volumes (this will remove unused volumes)..."
              try {
                docker volume prune -f 2>&1 | Write-Host
              } catch {
                Write-Warning "docker volume prune failed: $($_.Exception.Message)"
              }

              Write-Host "Removing unused builder cache and performing system prune (including containers/networks)..."
              try {
                docker system prune -af --volumes 2>&1 | Write-Host
              } catch {
                Write-Warning "docker system prune failed: $($_.Exception.Message)"
              }
            }
          }
      

