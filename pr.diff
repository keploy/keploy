diff --git a/utils/grpc.go b/utils/grpc.go
index a8d14f678a..f28e805bec 100644
--- a/utils/grpc.go
+++ b/utils/grpc.go
@@ -21,10 +21,6 @@ import (
 )
 
 func GetProtoMessageDescriptor(ctx context.Context, logger *zap.Logger, pc models.ProtoConfig) (protoreflect.MessageDescriptor, []protoreflect.FileDescriptor, error) {
-	if pc.ProtoFile == "" && pc.ProtoDir == "" {
-		return nil, nil, fmt.Errorf("protoFile or protoDir must be provided")
-	}
-
 	if pc.RequestURI == "" {
 		return nil, nil, fmt.Errorf("requestURI must be provided, eg:/service.DataService/GetComplexData")
 	}
@@ -34,6 +30,21 @@ func GetProtoMessageDescriptor(ctx context.Context, logger *zap.Logger, pc model
 	protoInclude := pc.ProtoInclude
 	grpcPath := pc.RequestURI
 
+	// Auto-derive protoDir from gRPC path when protoInclude is available.
+	// This enables multi-service scenarios where different requests need different proto directories.
+	if len(protoInclude) > 0 && grpcPath != "" {
+		derived, err := deriveProtoDirFromPath(grpcPath, protoInclude)
+		if err == nil {
+			protoDir = derived // Use derived directory, taking precedence over config
+		}
+		// If derivation fails, fall through to use config's protoDir
+	}
+
+	// Validate that we have at least one source of proto files
+	if protoPath == "" && protoDir == "" {
+		return nil, nil, fmt.Errorf("protoFile or protoDir must be provided (auto-derive from protoInclude also failed)")
+	}
+
 	// Normalize protoInclude roots to absolute.
 	var absRoots []string
 	for _, p := range protoInclude {
@@ -226,6 +237,63 @@ func relToAny(abs string, roots []string) string {
 	return ""
 }
 
+// deriveProtoDirFromPath extracts the package from a gRPC path and searches protoInclude roots
+// for a matching directory. This enables automatic proto directory resolution for multi-service
+// scenarios where a single protoDir config is insufficient.
+//
+// It uses a multi-strategy approach following protobuf conventions:
+//  1. Full package path: "homework.v1.Homework" → "homework/v1/"
+//  2. First segment only: "homework.v1.Homework" → "homework/"
+//
+// Returns the first matching directory path, or an error if none found.
+func deriveProtoDirFromPath(grpcPath string, protoIncludes []string) (string, error) {
+	if grpcPath == "" || len(protoIncludes) == 0 {
+		return "", fmt.Errorf("grpcPath and protoIncludes are required")
+	}
+
+	// Parse gRPC path to get service full name (e.g., "homework.v1.Homework")
+	serviceFull, _, err := ParseGRPCPath(grpcPath)
+	if err != nil {
+		return "", fmt.Errorf("failed to parse gRPC path: %w", err)
+	}
+
+	parts := strings.Split(serviceFull, ".")
+	if len(parts) == 0 {
+		return "", fmt.Errorf("cannot extract package from service %q", serviceFull)
+	}
+
+	// Build search strategies in order of likelihood:
+	// 1. Full package path (minus service name): "homework.v1.Homework" → "homework/v1"
+	// 2. First segment only: "homework"
+	var strategies []string
+
+	// Strategy 1: Full package path (remove service name - last part)
+	if len(parts) > 1 {
+		packageParts := parts[:len(parts)-1] // ["homework", "v1"]
+		strategies = append(strategies, filepath.Join(packageParts...))
+	}
+
+	// Strategy 2: First segment only
+	strategies = append(strategies, parts[0])
+
+	// Search protoInclude roots for matching directory
+	for _, root := range protoIncludes {
+		absRoot, err := mustAbs(root)
+		if err != nil || absRoot == "" {
+			continue
+		}
+
+		for _, strategy := range strategies {
+			candidateDir := filepath.Join(absRoot, strategy)
+			if info, err := os.Stat(candidateDir); err == nil && info.IsDir() {
+				return candidateDir, nil
+			}
+		}
+	}
+
+	return "", fmt.Errorf("no proto directory found for service %q in protoInclude roots (tried: %v)", serviceFull, strategies)
+}
+
 // ProtoTextToWire turns Protoscope text into wire bytes using the library (no exec).
 func ProtoTextToWire(text string) ([]byte, error) {
 	sc := protoscope.NewScanner(text) // expects string
diff --git a/utils/grpc_test.go b/utils/grpc_test.go
index 0b6b40cf2e..2c7eccfd8c 100644
--- a/utils/grpc_test.go
+++ b/utils/grpc_test.go
@@ -2,6 +2,7 @@ package utils
 
 import (
 	"context"
+	"os"
 	"testing"
 
 	"go.keploy.io/server/v2/pkg/models"
@@ -47,3 +48,114 @@ func TestCreateTypeResolver(t *testing.T) {
 		t.Error("Expected non-nil type resolver")
 	}
 }
+
+func TestDeriveProtoDirFromPath(t *testing.T) {
+	// Create temporary directory structure for testing
+	tmpDir := t.TempDir()
+
+	// Create test directories simulating common-protos structure
+	// homework/v1/, classroom/v1/, google/protobuf/
+	testDirs := []string{
+		"homework/v1",
+		"classroom/v1",
+		"google/protobuf",
+		"com/example/service/v1",
+	}
+	for _, d := range testDirs {
+		if err := os.MkdirAll(tmpDir+"/"+d, 0755); err != nil {
+			t.Fatalf("Failed to create test directory: %v", err)
+		}
+	}
+
+	tests := []struct {
+		name           string
+		grpcPath       string
+		protoIncludes  []string
+		wantDir        string
+		wantErrContain string
+	}{
+		{
+			name:          "homework.v1.Homework -> homework/v1",
+			grpcPath:      "/homework.v1.Homework/CreateHomework",
+			protoIncludes: []string{tmpDir},
+			wantDir:       tmpDir + "/homework/v1",
+		},
+		{
+			name:          "classroom.v1.Meeting -> classroom/v1",
+			grpcPath:      "/classroom.v1.Meeting/StartMeeting",
+			protoIncludes: []string{tmpDir},
+			wantDir:       tmpDir + "/classroom/v1",
+		},
+		{
+			name:          "google.protobuf.Empty -> google/protobuf",
+			grpcPath:      "/google.protobuf.Empty/Method",
+			protoIncludes: []string{tmpDir},
+			wantDir:       tmpDir + "/google/protobuf",
+		},
+		{
+			name:          "com.example.service.v1.Foo -> com/example/service/v1",
+			grpcPath:      "/com.example.service.v1.Foo/Method",
+			protoIncludes: []string{tmpDir},
+			wantDir:       tmpDir + "/com/example/service/v1",
+		},
+		{
+			name:           "nonexistent package falls back with error",
+			grpcPath:       "/nonexistent.v1.Service/Method",
+			protoIncludes:  []string{tmpDir},
+			wantErrContain: "no proto directory found",
+		},
+		{
+			name:           "empty protoIncludes returns error",
+			grpcPath:       "/homework.v1.Homework/CreateHomework",
+			protoIncludes:  []string{},
+			wantErrContain: "grpcPath and protoIncludes are required",
+		},
+		{
+			name:           "invalid gRPC path returns error",
+			grpcPath:       "invalid-path",
+			protoIncludes:  []string{tmpDir},
+			wantErrContain: "failed to parse gRPC path",
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := deriveProtoDirFromPath(tt.grpcPath, tt.protoIncludes)
+
+			if tt.wantErrContain != "" {
+				if err == nil {
+					t.Errorf("expected error containing %q, got nil", tt.wantErrContain)
+					return
+				}
+				if !contains(err.Error(), tt.wantErrContain) {
+					t.Errorf("expected error containing %q, got %q", tt.wantErrContain, err.Error())
+				}
+				return
+			}
+
+			if err != nil {
+				t.Errorf("unexpected error: %v", err)
+				return
+			}
+
+			if got != tt.wantDir {
+				t.Errorf("got %q, want %q", got, tt.wantDir)
+			}
+		})
+	}
+}
+
+// Helper function for string contains check
+func contains(s, substr string) bool {
+	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
+		(len(s) > 0 && len(substr) > 0 && findSubstring(s, substr)))
+}
+
+func findSubstring(s, substr string) bool {
+	for i := 0; i <= len(s)-len(substr); i++ {
+		if s[i:i+len(substr)] == substr {
+			return true
+		}
+	}
+	return false
+}
