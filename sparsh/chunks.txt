[{"chunk_id":2,"content":"func addHeightPadding(rows int, columns int, columnWidths []int) string {\n\tpadding := \"\"\n\tfor i := 0; i \u003c rows; i++ {\n\t\tfor j := 0; j \u003c columns; j++ {\n\t\t\tif j == columns-1 {\n\t\t\t\tpadding += fmt.Sprintf(\"| %-*s |\\n\", columnWidths[j], \"\")\n\t\t\t} else {\n\t\t\t\tpadding += fmt.Sprintf(\"| %-*s \", columnWidths[j], \"\")\n\t\t\t}\n\t\t}\n\t}\n\treturn padding\n}\n\nfunc statusUpdater(stop \u003c-chan bool) {\n\tmessages := []string{\n\t\t\"Running tests... Please wait.\",\n\t\t\"Still running tests... Hang tight!\",\n\t\t\"Tests are still executing... Almost there!\",\n\t}\n\ti := 0\n\tfor {\n\t\tselect {\n\t\tcase \u003c-stop:\n\t\t\tfmt.Printf(\"\\r\\033[K\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Printf(\"\\r\\033[K%s\", messages[i%len(messages)])\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\ti++\n\t\t}\n\t}\n}\n\nfunc (g *UnitTestGenerator) runCoverage() error {\n\t// Perform an initial build/test command to generate coverage report and get a baseline\n\tif g.srcPath != \"\" {\n\t\tg.logger.Info(fmt.Sprintf(\"Running test command to generate coverage report: '%s'\", g.cmd))\n\t}\n\n\tstopStatus := make(chan bool)\n\tgo statusUpdater(stopStatus)\n\n\tstartTime := time.Now()\n\n\t_, _, exitCode, lastUpdatedTime, err := RunCommand(g.cmd, g.dir, g.logger)\n\tduration := time.Since(startTime)\n\tstopStatus \u003c- true\n\tg.logger.Info(fmt.Sprintf(\"Test command completed in %v\", formatDuration(duration)))\n\n\tif err != nil {\n\t\tg.logger.Warn(\"Test command failed. Ensure no tests are failing, and rerun the command.\")\n\t\treturn fmt.Errorf(\"error running test command: %s\", g.cmd)\n\t}\n\tif exitCode != 0 {\n\t\tutils.LogError(g.logger, err, \"Error running test command\")\n\t}\n\tcoverageProcessor := NewCoverageProcessor(g.cov.Path, getFilename(g.srcPath), g.cov.Format)\n\tcoverageResult, err := coverageProcessor.ProcessCoverageReport(lastUpdatedTime)\n\tif err != nil {\n\t\tutils.LogError(g.logger, err, \"Error in coverage processing\")\n\t\treturn fmt.Errorf(\"error in coverage processing: %w\", err)\n\t}\n\tg.cov.Current = coverageResult.Coverage\n\tg.cov.Content = coverageResult.ReportContent\n\tif g.srcPath == \"\" {\n\t\tg.Files = coverageResult.Files\n\t}\n\treturn nil\n}\n\nfunc (g *UnitTestGenerator) GenerateTests(ctx context.Context, iterationCount int) (*models.UTDetails, error) {\n\tfmt.Println(\"Generating Tests...\")\n\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\terr := ctx.Err()\n\t\treturn \u0026models.UTDetails{}, err\n\tdefault:\n\t}\n\n\trequestPurpose := TestForFile\n\tif len(g.ai.FunctionUnderTest) \u003e 0 {\n\t\trequestPurpose = TestForFunction\n\t}\n\n\tupdatedTestContent, err := readFile(g.testPath)\n\tif err != nil {\n\t\tg.logger.Error(\"Error reading updated test file content\", zap.Error(err))\n\t\treturn \u0026models.UTDetails{}, err\n\t}\n\tg.promptBuilder.Test.Code = updatedTestContent\n\tg.promptBuilder.CovReportContent = g.cov.Content\n\tg.prompt, err = g.promptBuilder.BuildPrompt(\"test_generation\", \"\")\n\tif err != nil {\n\t\tutils.LogError(g.logger, err, \"Error building prompt\")\n\t\treturn \u0026models.UTDetails{}, err\n\t}\n\n\taiRequest := AIRequest{\n\t\tMaxTokens:      4096,\n\t\tPrompt:         *g.prompt,\n\t\tSessionID:      g.ai.SessionID,\n\t\tIteration:      iterationCount,\n\t\tRequestPurpose: requestPurpose,\n\t}\n\n\tresponse, err := g.ai.Call(ctx, CompletionParams{}, aiRequest, false)\n\tif err != nil {\n\t\treturn \u0026models.UTDetails{}, err\n\t}\n\n\ttestsDetails, err := unmarshalYamlTestDetails(response)\n\tif err != nil {\n\t\tutils.LogError(g.logger, err, \"Error unmarshalling test details\")\n\t\treturn \u0026models.UTDetails{}, err\n\t}\n\n\treturn testsDetails, nil\n}\n\nfunc (g *UnitTestGenerator) setCursor(ctx context.Context) error {\n\tfmt.Println(\"Getting indentation for new Tests...\")\n\tindentation, err := g.getIndentation(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to analyze test headers indentation: %w\", err)\n\t}\n\tfmt.Println(\"Getting Line number for new Tests...\")\n\tline, err := g.getLine(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to analyze relevant line number to insert new tests: %w\", err)\n\t}\n\tg.cur.Indentation = indentation\n\tg.cur.Line = line\n\treturn nil\n}\n\nfunc (g *UnitTestGenerator) getIndentation(ctx context.Context) (int, error) {\n\tindentation := -1\n\tallowedAttempts := 3\n\tcounterAttempts := 0\n\tfor indentation == -1 \u0026\u0026 counterAttempts \u003c allowedAttempts {\n\t\tprompt, err := g.promptBuilder.BuildPrompt(\"indentation\", \"\")\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"error building prompt: %w\", err)\n\t\t}\n\n\t\taiRequest := AIRequest{\n\t\t\tMaxTokens: 4096,\n\t\t\tPrompt:    *prompt,\n\t\t\tSessionID: g.ai.SessionID,\n\t\t}\n\t\tresponse, err := g.ai.Call(ctx, CompletionParams{}, aiRequest, false)\n\t\tif err != nil {\n\t\t\tutils.LogError(g.logger, err, \"Error calling AI model\")\n\t\t\treturn 0, err\n\t\t}\n\t\ttestsDetails, err := unmarshalYamlTestHeaders(response)\n\t\tif err != nil {\n\t\t\tutils.LogError(g.logger, err, \"Error unmarshalling test headers\")\n\t\t\treturn 0, err\n\t\t}\n\n\t\tindentation, err = convertToInt(testsDetails.Indentation)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"error converting test_headers_indentation to int: %w\", err)\n\t\t}\n\t\tcounterAttempts++\n\t}\n\tif indentation == -1 {\n\t\treturn 0, fmt.Errorf(\"failed to analyze the test headers indentation\")\n\t}\n\treturn indentation, nil\n}\n\nfunc (g *UnitTestGenerator) getLine(ctx context.Context) (int, error) {\n\tline := -1\n\tallowedAttempts := 3\n\tcounterAttempts := 0\n\tfor line == -1 \u0026\u0026 counterAttempts \u003c allowedAttempts {\n\t\tprompt, err := g.promptBuilder.BuildPrompt(\"insert_line\", \"\")\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"error building prompt: %w\", err)\n\t\t}\n\n\t\taiRequest := AIRequest{\n\t\t\tMaxTokens: 4096,\n\t\t\tPrompt:    *prompt,\n\t\t\tSessionID: g.ai.SessionID,\n\t\t}\n\t\tresponse, err := g.ai.Call(ctx, CompletionParams{}, aiRequest, false)\n\t\tif err != nil {\n\t\t\tutils.LogError(g.logger, err, \"Error calling AI model\")\n\t\t\treturn 0, err\n\t\t}\n\t\ttestsDetails, err := unmarshalYamlTestLine(response)\n\t\tif err != nil {\n\t\t\tutils.LogError(g.logger, err, \"Error unmarshalling test line\")\n\t\t\treturn 0, err\n\t\t}\n\n\t\tline, err = convertToInt(testsDetails.Line)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"error converting relevant_line_number_to_insert_after to int: %w\", err)\n\t\t}\n\t\tcounterAttempts++\n\t}\n\tif line == -1 {\n\t\treturn 0, fmt.Errorf(\"failed to analyze the relevant line number to insert new tests\")\n\t}\n\treturn line, nil\n}\n\nfunc (g *UnitTestGenerator) ValidateTest(\n\tgeneratedTest models.UT,\n\tpassedTests,\n\tnoCoverageTest,\n\tfailedBuild *int,\n\tinstalledPackages []string,\n) (bool, error) {\n\ttestCode := strings.TrimSpace(generatedTest.TestCode)\n\tInsertAfter := g.cur.Line\n\tIndent := g.cur.Indentation\n\ttestCodeIndented := testCode\n\tif Indent != 0 {\n\t\tinitialIndent := len(testCode) - len(strings.TrimLeft(testCode, \" \"))\n\t\tdeltaIndent := Indent - initialIndent\n\t\tif deltaIndent \u003e 0 {\n\t\t\tlines := strings.Split(testCode, \"\\n\")\n\t\t\tfor i, line := range lines {\n\t\t\t\tlines[i] = strings.Repeat(\" \", deltaIndent) + line\n\t\t\t}\n\t\t\ttestCodeIndented = strings.Join(lines, \"\\n\")\n\t\t}\n\t}\n\ttestCodeIndented = \"\\n\" + g.injector.addCommentToTest(strings.TrimSpace(testCodeIndented)) + \"\\n\"\n\toriginalContent, err := readFile(g.testPath)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"failed to read test file: %w\", err)\n\t}\n\toriginalContentLines := strings.Split(originalContent, \"\\n\")\n\ttestCodeLines := strings.Split(testCodeIndented, \"\\n\")\n\tif InsertAfter \u003e len(originalContentLines) {\n\t\tInsertAfter = len(originalContentLines)\n\t}\n\tprocessedTestLines := append(originalContentLines[:InsertAfter], testCodeLines...)\n\tprocessedTestLines = append(processedTestLines, originalContentLines[InsertAfter:]...)\n\tprocessedTest := strings.Join(processedTestLines, \"\\n\")\n\tif err := os.WriteFile(g.testPath, []byte(processedTest), 0644); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to write test file: %w\", err)\n\t}\n\timportLen, err := g.injector.updateImports(g.testPath, generatedTest.NewImportsCode)\n\tif err != nil {\n\t\tg.logger.Warn(\"Error updating imports\", zap.Error(err))\n\t}\n\tnewInstalledPackages, err := g.injector.installLibraries(generatedTest.LibraryInstallationCode, installedPackages)\n\tif err != nil {\n\t\tg.logger.Debug(\"Error installing libraries\", zap.Error(err))\n\t}\n\n\tg.logger.Info(fmt.Sprintf(\"Running Test with command: '%s'\", g.cmd))\n\tstdout, stderr, exitCode, timeOfTestCommand, _ := RunCommand(g.cmd, g.dir, g.logger)\n\tif exitCode != 0 {\n\t\tg.logger.Info(\"Test Run Failed\")\n\t\tif err := os.WriteFile(g.testPath, []byte(originalContent), 0644); err != nil {\n\t\t\treturn false, fmt.Errorf(\"failed to revert test file: %w\", err)\n\t\t}\n\t\terr = g.injector.uninstallLibraries(newInstalledPackages)\n\t\tif err != nil {\n\t\t\tg.logger.Warn(\"Error uninstalling libraries\", zap.Error(err))\n\t\t}\n\t\t// Mark test as failed\n\t\tg.failedTests = append(g.failedTests, \u0026models.FailedUT{\n\t\t\tTestCode:                generatedTest.TestCode,\n\t\t\tErrorMsg:                extractErrorMessage(stdout, stderr, g.lang),\n\t\t\tNewImportsCode:          generatedTest.NewImportsCode,\n\t\t\tLibraryInstallationCode: generatedTest.LibraryInstallationCode,\n\t\t})\n\t\tg.testCaseFailed++\n\t\t*failedBuild++\n\t\treturn false, nil\n\t}\n\n\tcoverageProcessor := NewCoverageProcessor(g.cov.Path, getFilename(g.srcPath), g.cov.Format)\n\tcoverageResult, err := coverageProcessor.ProcessCoverageReport(timeOfTestCommand)\n\tif err != nil {\n\t\tutils.LogError(g.logger, err, \"Error in coverage processing\")\n\t\treturn false, fmt.Errorf(\"error in coverage processing: %w\", err)\n\t}\n\tinitialCoverage := g.cov.Current\n\tg.cov.Current = coverageResult.Coverage\n\tg.cov.Content = coverageResult.ReportContent\n\tif g.srcPath == \"\" {\n\t\tg.Files = coverageResult.Files\n\t}\n\n\tcoverageIncreased := g.cov.Current \u003e initialCoverage\n\tif !coverageIncreased {\n\t\tg.logger.Info(\"No coverage increase detected after initial test run.\")\n\t\t// Revert test file to original content\n\t\tif err := os.WriteFile(g.testPath, []byte(originalContent), 0644); err != nil {\n\t\t\treturn false, fmt.Errorf(\"failed to revert test file: %w\", err)\n\t\t}\n\t\t// Uninstall any installed libraries\n\t\terr = g.injector.uninstallLibraries(newInstalledPackages)\n\t\tif err != nil {\n\t\t\tg.logger.Warn(\"Error uninstalling libraries\", zap.Error(err))\n\t\t}\n\t\t// Mark test as ineffective\n\t\tg.noCoverageTest++\n\t\t*noCoverageTest++\n\t\treturn false, nil\n\t}\n\n\tif g.flakiness {\n\t\t// Run the Test Five Times to Check for Flakiness\n\t\tg.logger.Info(\"Coverage increased. Running additional test iterations to check for flakiness.\")\n\t\tfor i := 0; i \u003c 5; i++ {\n\t\t\tg.logger.Info(fmt.Sprintf(\"Flakiness Check - Iteration no: %d\", i+1))\n\t\t\tstdout, stderr, exitCode, _, _ := RunCommand(g.cmd, g.dir, g.logger)\n\t\t\tif exitCode != 0 {\n\t\t\t\tg.logger.Info(fmt.Sprintf(\"Flaky test detected on iteration %d: %s\", i+1, stderr))\n\t\t\t\t// Revert test file to original content\n\t\t\t\tif err := os.WriteFile(g.testPath, []byte(originalContent), 0644); err != nil {\n\t\t\t\t\treturn false, fmt.Errorf(\"failed to revert test file: %w\", err)\n\t\t\t\t}\n\t\t\t\t// Uninstall any installed libraries\n\t\t\t\terr = g.injector.uninstallLibraries(newInstalledPackages)\n\t\t\t\tif err != nil {\n\t\t\t\t\tg.logger.Warn(\"Error uninstalling libraries\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\tg.failedTests = append(g.failedTests, \u0026models.FailedUT{\n\t\t\t\t\tTestCode:                generatedTest.TestCode,\n\t\t\t\t\tErrorMsg:                extractErrorMessage(stdout, stderr, g.lang),\n\t\t\t\t\tNewImportsCode:          generatedTest.NewImportsCode,\n\t\t\t\t\tLibraryInstallationCode: generatedTest.LibraryInstallationCode,\n\t\t\t\t})\n\t\t\t\tg.testCaseFailed++\n\t\t\t\t*failedBuild++\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t}\n\t}\n\tg.testCasePassed++\n\t*passedTests++\n\tg.cov.Current = coverageResult.Coverage\n\tg.logger.Info(\"Generated test passed and increased coverage\")\n\tg.cur.Line = g.cur.Line + len(testCodeLines) + importLen\n\treturn true, nil\n}\n\nfunc (g *UnitTestGenerator) saveFailedTestCasesToFile() error {\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error getting current directory: %w\", err)\n\t}\n\n\tnewFilePath := filepath.Join(dir, discardedTestsFilename)\n\n\tfileHandle, err := os.OpenFile(newFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error opening discarded tests file: %w\", err)\n\t}\n\n\tdefer func() {\n\t\terr := fileHandle.Close()\n\t\tif err != nil {\n\t\t\tg.logger.Error(\"Error closing file handle\", zap.Error(err))\n\t\t}\n\t}()\n\n\tvar builder strings.Builder\n\n\t// Writing Test Cases To File\n\tfor _, failedTest := range g.failedTests {\n\t\tbuilder.WriteString(\"\\n\" + strings.Repeat(\"-\", 20) + \"Test Case\" + strings.Repeat(\"-\", 20) + \"\\n\")\n\t\tif len(failedTest.NewImportsCode) \u003e 0 {\n\t\t\tbuilder.WriteString(fmt.Sprintf(\"Import Statements:\\n%s\\n\", failedTest.NewImportsCode))\n\t\t}\n\t\tif len(failedTest.LibraryInstallationCode) \u003e 0 {\n\t\t\tbuilder.WriteString(fmt.Sprintf(\"Required Library Installation\\n%s\\n\", failedTest.LibraryInstallationCode))\n\t\t}\n\t\tbuilder.WriteString(fmt.Sprintf(\"Test Implementation:\\n%s\\n\\n\", failedTest.TestCode))\n\t\tif len(failedTest.ErrorMsg) \u003e 0 {\n\t\t\tbuilder.WriteString(fmt.Sprintf(\"Error Message:\\n%s\\n\", failedTest.ErrorMsg))\n\t\t}\n\t\tbuilder.WriteString(strings.Repeat(\"-\", 49) + \"\\n\")\n\t}\n\n\t_, err = fileHandle.WriteString(fmt.Sprintf(\"%s\\n\", builder.String()))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error writing to discarded tests file: %w\", err)\n\t}\n\treturn nil\n}\n"},{"chunk_id":3,"content":"\t\tg.logger.Info(\"Source code analysis complete - no refactoring needed (empty refactored code)\")\n\t}\n\n\treturn nil\n}\n"},{"chunk_id":1,"content":"// Package utgen is a service that generates unit tests for a given source code file.\npackage utgen\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/k0kubun/pp/v3\"\n\t\"go.keploy.io/server/v2/config\"\n\t\"go.keploy.io/server/v2/pkg/models\"\n\t\"go.keploy.io/server/v2/pkg/service\"\n\t\"go.keploy.io/server/v2/utils\"\n\t\"go.uber.org/zap\"\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype Coverage struct {\n\tPath    string\n\tFormat  string\n\tDesired float64\n\tCurrent float64\n\tContent string\n}\n\ntype Cursor struct {\n\tLine        int\n\tIndentation int\n}\n\ntype UnitTestGenerator struct {\n\tsrcPath          string\n\ttestPath         string\n\tcmd              string\n\tdir              string\n\tcov              *Coverage\n\tlang             string\n\tcur              *Cursor\n\tfailedTests      []*models.FailedUT\n\tprompt           *Prompt\n\tai               *AIClient\n\tlogger           *zap.Logger\n\tpromptBuilder    *PromptBuilder\n\tinjector         *Injector\n\tmaxIterations    int\n\tFiles            []string\n\ttel              Telemetry\n\tadditionalPrompt string\n\ttotalTestCase    int\n\ttestCasePassed   int\n\ttestCaseFailed   int\n\tnoCoverageTest   int\n\tflakiness        bool\n\tsourceRefactored bool\n}\n\nvar discardedTestsFilename = \"discardedTests.txt\"\n\nfunc NewUnitTestGenerator(\n\tcfg *config.Config,\n\ttel Telemetry,\n\tauth service.Auth,\n\tlogger *zap.Logger,\n) (*UnitTestGenerator, error) {\n\tgenConfig := cfg.Gen\n\n\tgenerator := \u0026UnitTestGenerator{\n\t\tsrcPath:       genConfig.SourceFilePath,\n\t\ttestPath:      genConfig.TestFilePath,\n\t\tcmd:           genConfig.TestCommand,\n\t\tdir:           genConfig.TestDir,\n\t\tmaxIterations: genConfig.MaxIterations,\n\t\tlogger:        logger,\n\t\ttel:           tel,\n\t\tai:            NewAIClient(genConfig, \"\", cfg.APIServerURL, auth, uuid.NewString(), logger),\n\t\tcov: \u0026Coverage{\n\t\t\tPath:    genConfig.CoverageReportPath,\n\t\t\tFormat:  genConfig.CoverageFormat,\n\t\t\tDesired: float64(genConfig.DesiredCoverage),\n\t\t},\n\t\tadditionalPrompt: genConfig.AdditionalPrompt,\n\t\tcur:              \u0026Cursor{},\n\t\tflakiness:        genConfig.Flakiness,\n\t\tsourceRefactored: false,\n\t}\n\n\tif generator.srcPath != \"\" \u0026\u0026 generator.testPath == \"\" {\n\t\t//srcPath is given, testPath is not\n\t\teffectiveTestDir := generator.dir\n\t\tif effectiveTestDir == \"\" { //set to \".\"\n\t\t\teffectiveTestDir = \".\"\n\t\t}\n\n\t\tderivedPath, err := getTestFilePath(generator.srcPath, effectiveTestDir)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to derive test file path\", zap.Error(err), zap.String(\"sourceFile\", generator.srcPath), zap.String(\"testDir\", effectiveTestDir))\n\t\t\treturn nil, fmt.Errorf(\"failed to derive test file path for %s: %w\", generator.srcPath, err)\n\t\t}\n\t\tgenerator.testPath = derivedPath\n\t\tlogger.Info(\"Test file path not provided, derived\", zap.String(\"derivedTestPath\", generator.testPath), zap.String(\"sourceFile\", generator.srcPath))\n\t}\n\n\treturn generator, nil\n}\n\nfunc (g *UnitTestGenerator) Start(ctx context.Context) error {\n\tg.tel.GenerateUT()\n\n\t// Check for context cancellation before proceeding\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn fmt.Errorf(\"process cancelled by user\")\n\tdefault:\n\t\t// Continue if no cancellation\n\t}\n\n\tisSingleFileMode := g.srcPath != \"\"\n\tvar filesToIterate []string\n\n\tif isSingleFileMode {\n\t\tfilesToIterate = append(filesToIterate, g.srcPath)\n\t} else { // Batch mode\n\t\tif err := g.runCoverage(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(g.Files) == 0 {\n\t\t\treturn fmt.Errorf(\"couldn't identify source files. Please specify source file using --source-file-path\")\n\t\t}\n\t\tfilesToIterate = g.Files\n\t}\n\tconst paddingHeight = 1\n\tcolumnWidths3 := []int{29, 29, 29}\n\tcolumnWidths2 := []int{40, 40}\n\n\tfor _, currentSrcPath := range filesToIterate {\n\t\tg.srcPath = currentSrcPath\n\n\t\t//If in batch mode or testPath not set\n\t\tif !isSingleFileMode || g.testPath == \"\" {\n\t\t\tderivedPath, err := getTestFilePath(g.srcPath, g.dir)\n\t\t\tif err != nil {\n\t\t\t\tg.logger.Error(\"Error deriving test file path\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tg.testPath = derivedPath\n\t\t}\n\n\t\tnewTestFile := false\n\t\tvar err error\n\n\t\t// Respect context cancellation in each iteration\n\t\tselect {\n\t\tcase \u003c-ctx.Done():\n\t\t\treturn fmt.Errorf(\"process cancelled by user\")\n\t\tdefault:\n\t\t}\n\n\t\tg.logger.Info(\"Generating tests for file\", zap.String(\"file\", g.srcPath))\n\t\tvar isEmptyFile bool\n\t\tif _, statErr := os.Stat(g.testPath); os.IsNotExist(statErr) {\n\t\t\ttestFileDir := filepath.Dir(g.testPath)\n\t\t\tif err := os.MkdirAll(testFileDir, os.ModePerm); err != nil {\n\t\t\t\tg.logger.Error(\"Error creating directory for test file\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcreated, err := createTestFile(g.testPath, g.srcPath)\n\t\t\tif err != nil {\n\t\t\t\tg.logger.Error(\"Error creating test file\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewTestFile = created\n\t\t\tisEmptyFile = created\n\t\t} else {\n\t\t\tisEmptyFile, err = utils.IsFileEmpty(g.testPath)\n\t\t\tif err != nil {\n\t\t\t\tg.logger.Error(\"Error checking if test file is empty\", zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewTestFile = isEmptyFile\n\t\t}\n\t\tif !newTestFile {\n\t\t\tif err = g.runCoverage(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tg.cov.Current = 0\n\t\t}\n\n\t\titerationCount := 1\n\t\tg.lang = GetCodeLanguage(g.srcPath)\n\n\t\tvar originalSrcCode string\n\t\tif !g.sourceRefactored {\n\t\t\terr = g.refactorSourceCode(ctx, \u0026originalSrcCode)\n\t\t\tif err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"Error during source code refactoring\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tg.promptBuilder, err = NewPromptBuilder(g.srcPath, g.testPath, g.cov.Content, \"\", \"\", g.lang, g.additionalPrompt, g.ai.FunctionUnderTest, g.sourceRefactored, g.logger)\n\t\tg.injector = NewInjectorBuilder(g.logger, g.lang)\n\n\t\tif err != nil {\n\t\t\tutils.LogError(g.logger, err, \"Error creating prompt builder\")\n\t\t\treturn err\n\t\t}\n\t\tif !isEmptyFile {\n\t\t\tif err := g.setCursor(ctx); err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"Error during initial test suite analysis\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tg.cur.Indentation = 0\n\t\t\tif g.lang == \"go\" {\n\t\t\t\tg.cur.Line = 1\n\t\t\t} else {\n\t\t\t\tg.cur.Line = 0\n\t\t\t}\n\t\t}\n\t\tinitialCoverage := g.cov.Current\n\t\tfor g.cov.Current \u003c (g.cov.Desired/100) \u0026\u0026 iterationCount \u003c= g.maxIterations {\n\t\t\tpassedTests, noCoverageTest, failedBuild, totalTest := 0, 0, 0, 0\n\t\t\tselect {\n\t\t\tcase \u003c-ctx.Done():\n\t\t\t\treturn fmt.Errorf(\"process cancelled by user\")\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tpp.SetColorScheme(models.GetPassingColorScheme())\n\t\t\tif _, err := pp.Printf(\"Current Coverage: %s%% for file %s\\n\", math.Round(g.cov.Current*100), g.srcPath); err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"failed to print coverage\")\n\t\t\t}\n\t\t\tif _, err := pp.Printf(\"Desired Coverage: %s%% for file %s\\n\", g.cov.Desired, g.srcPath); err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"failed to print coverage\")\n\t\t\t}\n\n\t\t\t// Check for failed tests:\n\t\t\tfailedTestRunsValue := \"\"\n\t\t\tif len(g.failedTests) \u003e 0 {\n\t\t\t\tfor _, failedTest := range g.failedTests {\n\t\t\t\t\tcode := failedTest.TestCode\n\t\t\t\t\terrorMessage := failedTest.ErrorMsg\n\t\t\t\t\tfailedTestRunsValue += fmt.Sprintf(\"Failed Test:\\n\\n%s\\n\\n\", code)\n\t\t\t\t\tif errorMessage != \"\" {\n\t\t\t\t\t\tfailedTestRunsValue += fmt.Sprintf(\"Error message for test above:\\n%s\\n\\n\\n\", errorMessage)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfailedTestRunsValue += \"\\n\\n\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tg.promptBuilder.InstalledPackages, err = g.injector.libraryInstalled()\n\t\t\tg.promptBuilder.ImportDetails = g.injector.getModelDetails(g.srcPath)\n\t\t\tg.promptBuilder.ModuleName, _ = g.injector.GetModuleName(g.srcPath)\n\t\t\tif err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"Error getting installed packages\")\n\t\t\t}\n\t\t\tg.prompt, err = g.promptBuilder.BuildPrompt(\"test_generation\", failedTestRunsValue)\n\t\t\tif err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"Error building prompt\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.failedTests = []*models.FailedUT{}\n\t\t\ttestsDetails, err := g.GenerateTests(ctx, iterationCount)\n\t\t\tif err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"Error generating tests\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif testsDetails == nil {\n\t\t\t\tg.logger.Info(\"No tests generated\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar overallCovInc = false\n\n\t\t\tg.logger.Info(\"Validating new generated tests one by one\")\n\t\t\tg.totalTestCase += len(testsDetails.NewTests)\n\t\t\ttotalTest = len(testsDetails.NewTests)\n\n\t\t\tfor _, generatedTest := range testsDetails.NewTests {\n\t\t\t\tinstalledPackages, err := g.injector.libraryInstalled()\n\t\t\t\tif err != nil {\n\t\t\t\t\tg.logger.Warn(\"Error getting installed packages\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase \u003c-ctx.Done():\n\t\t\t\t\treturn fmt.Errorf(\"process cancelled by user\")\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\tcoverageInc, err := g.ValidateTest(generatedTest, \u0026passedTests, \u0026noCoverageTest, \u0026failedBuild, installedPackages)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.LogError(g.logger, err, \"Error validating test\")\n\n\t\t\t\t\tif g.sourceRefactored \u0026\u0026 originalSrcCode != \"\" {\n\t\t\t\t\t\trerr := revertSourceCode(g.srcPath, originalSrcCode, true)\n\t\t\t\t\t\tif rerr != nil {\n\t\t\t\t\t\t\tutils.LogError(g.logger, rerr, \"Error reverting source code\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\toverallCovInc = overallCovInc || coverageInc\n\t\t\t}\n\n\t\t\tif g.cov.Current \u003c (g.cov.Desired/100) \u0026\u0026 g.cov.Current \u003e 0 {\n\t\t\t\tif err := g.runCoverage(); err != nil {\n\t\t\t\t\tutils.LogError(g.logger, err, \"Error running coverage\")\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(g.failedTests) \u003e 0 {\n\t\t\t\terr := g.saveFailedTestCasesToFile()\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.LogError(g.logger, err, \"Error adding failed test cases to file\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfmt.Printf(\"\\n\u003c=========================================\u003e\\n\")\n\t\t\tfmt.Printf((\"Tests generated in Session\") + \"\\n\")\n\t\t\tfmt.Printf(\"+-------------------------------+-------------------------------+-------------------------------+\\n\")\n\t\t\tfmt.Printf(\"| %s | %s | %s |\\n\",\n\t\t\t\tcenterAlignText(\"Total Test Cases\", 29),\n\t\t\t\tcenterAlignText(\"Test Cases Passed\", 29),\n\t\t\t\tcenterAlignText(\"Test Cases Failed\", 29))\n\t\t\tfmt.Printf(\"+-------------------------------+-------------------------------+-------------------------------+\\n\")\n\t\t\tfmt.Print(addHeightPadding(paddingHeight, 3, columnWidths3))\n\t\t\tfmt.Printf(\"| \\033[33m%s\\033[0m | \\033[32m%s\\033[0m | \\033[33m%s\\033[0m |\\n\",\n\t\t\t\tcenterAlignText(fmt.Sprintf(\"%d\", totalTest), 29),\n\t\t\t\tcenterAlignText(fmt.Sprintf(\"%d\", passedTests), 29),\n\t\t\t\tcenterAlignText(fmt.Sprintf(\"%d\", failedBuild+noCoverageTest), 29))\n\t\t\tfmt.Print(addHeightPadding(paddingHeight, 3, columnWidths3))\n\t\t\tfmt.Printf(\"+-------------------------------+-------------------------------+-------------------------------+\\n\")\n\t\t\tfmt.Printf((\"Discarded tests in session\") + \"\\n\")\n\t\t\tfmt.Printf(\"+------------------------------------------+------------------------------------------+\\n\")\n\t\t\tfmt.Printf(\"| %s | %s |\\n\",\n\t\t\t\tcenterAlignText(\"Build failures\", 40),\n\t\t\t\tcenterAlignText(\"No Coverage output\", 40))\n\t\t\tfmt.Printf(\"+------------------------------------------+------------------------------------------+\\n\")\n\t\t\tfmt.Print(addHeightPadding(paddingHeight, 2, columnWidths2))\n\t\t\tfmt.Printf(\"| \\033[35m%s\\033[0m | \\033[92m%s\\033[0m |\\n\",\n\t\t\t\tcenterAlignText(fmt.Sprintf(\"%d\", failedBuild), 40),\n\t\t\t\tcenterAlignText(fmt.Sprintf(\"%d\", noCoverageTest), 40))\n\t\t\tfmt.Print(addHeightPadding(paddingHeight, 2, columnWidths2))\n\t\t\tfmt.Printf(\"+------------------------------------------+------------------------------------------+\\n\")\n\t\t\tfmt.Printf(\"\u003c=========================================\u003e\\n\")\n\t\t\terr = g.ai.SendCoverageUpdate(ctx, g.ai.SessionID, initialCoverage, g.cov.Current, iterationCount)\n\t\t\tif err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"Error sending coverage update\")\n\t\t\t}\n\n\t\t\titerationCount++\n\t\t}\n\n\t\tif g.cov.Current == 0 \u0026\u0026 newTestFile {\n\t\t\terr := os.Remove(g.testPath)\n\t\t\tif err != nil {\n\t\t\t\tg.logger.Error(\"Error removing test file\", zap.Error(err))\n\t\t\t}\n\t\t}\n\n\t\tpp.SetColorScheme(models.GetPassingColorScheme())\n\t\tif g.cov.Current \u003e= (g.cov.Desired / 100) {\n\t\t\tif _, err := pp.Printf(\"For File %s Reached above target coverage of %s%% (Current Coverage: %s%%) in %s iterations.\\n\", g.srcPath, g.cov.Desired, math.Round(g.cov.Current*100), iterationCount); err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"failed to print coverage\")\n\t\t\t}\n\t\t} else if iterationCount \u003e g.maxIterations {\n\t\t\tif _, err := pp.Printf(\"For File %s Reached maximum iteration limit without achieving desired coverage. Current Coverage: %s%%\\n\", g.srcPath, math.Round(g.cov.Current*100)); err != nil {\n\t\t\t\tutils.LogError(g.logger, err, \"failed to print coverage\")\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"\\n\u003c=========================================\u003e\\n\")\n\tfmt.Printf((\"COMPLETE TEST GENERATE SUMMARY\") + \"\\n\")\n\tfmt.Printf((\"Total Test Summary\") + \"\\n\")\n\n\tfmt.Printf(\"+-------------------------------+-------------------------------+-------------------------------+\\n\")\n\tfmt.Printf(\"| %s | %s | %s |\\n\",\n\t\tcenterAlignText(\"Total Test Cases\", 29),\n\t\tcenterAlignText(\"Test Cases Passed\", 29),\n\t\tcenterAlignText(\"Test Cases Failed\", 29))\n\n\tfmt.Printf(\"+-------------------------------+-------------------------------+-------------------------------+\\n\")\n\tfmt.Print(addHeightPadding(paddingHeight, 3, columnWidths3))\n\tfmt.Printf(\"| \\033[33m%s\\033[0m | \\033[32m%s\\033[0m | \\033[33m%s\\033[0m |\\n\",\n\t\tcenterAlignText(fmt.Sprintf(\"%d\", g.totalTestCase), 29),\n\t\tcenterAlignText(fmt.Sprintf(\"%d\", g.testCasePassed), 29),\n\t\tcenterAlignText(fmt.Sprintf(\"%d\", g.testCaseFailed+g.noCoverageTest), 29))\n\tfmt.Print(addHeightPadding(paddingHeight, 3, columnWidths3))\n\tfmt.Printf(\"+-------------------------------+-------------------------------+-------------------------------+\\n\")\n\n\tfmt.Printf((\"Discarded Cases Summary\") + \"\\n\")\n\tfmt.Printf(\"+------------------------------------------+------------------------------------------+\\n\")\n\tfmt.Printf(\"| %s | %s |\\n\",\n\t\tcenterAlignText(\"Build failures\", 40),\n\t\tcenterAlignText(\"No Coverage output\", 40))\n\n\tfmt.Printf(\"+------------------------------------------+------------------------------------------+\\n\")\n\tfmt.Print(addHeightPadding(paddingHeight, 2, columnWidths2))\n\tfmt.Printf(\"| \\033[35m%s\\033[0m | \\033[92m%s\\033[0m |\\n\",\n\t\tcenterAlignText(fmt.Sprintf(\"%d\", g.testCaseFailed), 40),\n\t\tcenterAlignText(fmt.Sprintf(\"%d\", g.noCoverageTest), 40))\n\tfmt.Print(addHeightPadding(paddingHeight, 2, columnWidths2))\n\tfmt.Printf(\"+------------------------------------------+------------------------------------------+\\n\")\n\n\tfmt.Printf(\"\u003c=========================================\u003e\\n\")\n\treturn nil\n}\n\nfunc revertSourceCode(srcPath, originalSrcCode string, codeModified bool) error {\n\tif !codeModified {\n\t\treturn nil\n\t}\n\n\tif err := os.WriteFile(srcPath, []byte(originalSrcCode), 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to revert source code to the original state:%w\", err)\n\t}\n\treturn nil\n}\n\nfunc centerAlignText(text string, width int) string {\n\ttext = strings.Trim(text, \"\\\"\")\n\n\ttextLen := len(text)\n\tif textLen \u003e= width {\n\t\treturn text\n\t}\n\n\tleftPadding := (width - textLen) / 2\n\trightPadding := width - textLen - leftPadding\n\n\treturn fmt.Sprintf(\"%s%s%s\", strings.Repeat(\" \", leftPadding), text, strings.Repeat(\" \", rightPadding))\n}\n"}]